#. https://github.com/aanastasiyatuz
Числа. Таск 15
Множественное присваивание.
В Python можно присвоить одну перменную к другой:

a = 'переменная А' 
b = a 
print(b) 
Так как, переменная a хранит в себе значение 'переменная А', то присвоив ее к переменной b, мы просто создали еще один "указатель" на место в памяти где хранится строка 'переменная А'.

Распечатав переменную b, получим:

переменная А 
В Python, также существует такая операция как множественное присваивание.

Множественное присваивание это возможность присвоить значения сразу нескольким переменным:

a, b = 1, 2 
print(a) 
print(b) 
теперь в перемнных а и b хранятся числа:

1 
2 
Задание 15
Объявите три переменные с целочисленными значениями first, second, third.
Затем обменяйте их значения в одно действие.
Переменной first присвойте значение переменной second.
Переменной third присвойте значение переменной first.
Переменной second присвойте значение переменной third.print(1)set1 = {1,2,3,4}
set2 = {1,2,1,1,1,4,5}
# {1, 2, 4, 5}
set3 = {(1,2,3), 3}

print(dir(set))

"==================Методы Set========================="
# add -добавляет элементы в set
set1 = {1,2,3}
set.add(3) # ничего не поменяется (3 уже там есть)
set1.add(4) # {1,2,3,4}
# pop - удаляет элемент из set по значению
set2 = {1,2,3}
setvv




"Основы Git. Task 2
Создайте папку test
Перейдите в нее
Создайте в ней гит репозиторий"


Основы Git. Task 3
Создайте файл test.txt
Откройте файл
Напишите туда hello world


Основы Git. Task 4
Создайте коммит с комментарием created test.txt


Основы Git. Task 5
Посмотрите историю коммитов



Основы Git. Task 6
Свяжите локальный репозиторий с репозиторем на GitHub, добавив remote origin.

Используйте:

SSH: git@github.com:student123/MyRepo.git





Основы Git. Task 7
Узнайте на какой ветке вы сейчас находитесь






Основы Git. Task 8
Закиньте изменения в удаленый репозиторий




Основы Git. Task 9
Создайте файл test2.txt
Откройте его
Запишите внутри python is the best






Основы Git. Task 10
Создайте коммит с комментарием created test2.txt





Основы Git. Task 11
Закиньте все изменения в удаленный репозиторий





Команды Linux Task 2
Задание 2
Перейдите в свою домашнюю папку




Команды Linux Task 3
Задание 3
Создайте папку под названием makers и перейдите в нее

Дерево файлов и папок:

/                                                    
    home/                                            
         *nastya/                                    
               makers/                              
Звездочкой обозначена директория в которой вы находитесь до выполнения вашей команды









Команды Linux Task 4
Задание 4
После того, как вы перешли в папку makers создайте внутри 3 папки c названиями: week1, week2, week3

Дерево файлов и папок:

/                                                    
    home/                                            
         nastya/                                     
               *makers/                              
                       week1/                        
                       week2/                        
                       week3/                       
                       
                       
                       
                       
                       
                       
                       
                       
                       
                       
                       
                       
                       
                       
Команды Linux Task 5
Задание 5
Перейдите в ранее созданную папку week1
Cоздайте файл test.txt
Дерево файлов и папок:

/                                                    
    home/                                            
         nastya/                                     
               *makers/                              
                       week1/                        
                              test.txt               
                       week2/                        
                       week3/   
                       
                       
                       
                       
                       
                       
                       
                       
Команды Linux Task 6
Задание 6
Напишите внутри файла test.txt предложение Hello world
                       
                       
                       
                       
                       
  Команды Linux Task 7
Задание 7
Выведите содержимое файла test.txt на стандартное устройство вывода                     
                       
                       
                       
                       



Команды Linux Task 8
Задание 8
Перейдите в домашнюю папку, используя специальный символ
                       
                       
                       
                       
                       
                     
Команды Linux Task 9
Задание 9
Перейдите в папку week1 из домашней папки

Дерево файлов и папок:

/                                                    
    home/                                            
         *nastya/                                    
               makers/                               
                       week1/                        
                              test.txt               
                       week2/                        
                       week3/                       q





`	
	


Команды Linux Task 10
Задание 10
Создайте внутри папки week1 три файла под названием test1.txt, test2.txt, test3.txt

Дерево файлов и папок:

/                                                    
    home/                                            
         nastya/                                     
               makers/                               
                       *week1/                       
                              test.txt               
                              test1.txt              
                              test2.txt              
                              test3.txt              
                       week2/                        
                       week3/                       












Команды Linux Task 11
Задание 11
Скопируйте содержимое файла test.txt в файл под названием test1.txt

Note: Используйте команду cat

Дерево файлов и папок:

/                                                    
    home/                                            
         nastya/                                     
               makers/                               
                      *week1/                        
                              test.txt               
                              test1.txt              
                              test2.txt              
                              test3.txt              
                       week2/                        
                       week3/                       














Команды Linux Task 12
Задание 12
Удалите файл test1.txt

Дерево файлов и папок:

/                                                    
    home/                                            
         nastya/                                     
               makers/                               
                       *week1/                       
                              test.txt               
                              test2.txt              
                              test3.txt              
                       week2/                        
                       week3/  			
                       
                       
                       
                       
                       
                 



Команды Linux Task 13
Задание 13
Выйдите из папки week1 в родительскую
Удалите папку week1 вместе с содержимым
Дерево файлов и папок:

/                                                    
    home/                                            
         nastya/                                     
               *makers/                              
                       week1/                        
                       week2/                        
                       week3/                       










Команды Linux Task 14
Задание 14
Перейдите в домашнюю папку по абсолютному пути /home/nastya/ (не используя ~).

Дерево файлов и папок:

/                                                    
    home/                                            
         nastya/                                     
               *makers/                              
                       week2/                        
                       week3/                       

	










Команды Linux Task 15
Задание 15
Cоздать файл file.txt,
Переместите файл file.txt в папку week2
Note: Не забудьте, где находится папка week2

Дерево файлов и папок:

/                                                    
    home/                                            
         *nastya/                                    
               makers/                               
                       week2/                        
                              file.txt               
                       week3/                       









Команды Linux Task 16
Задание 16
Введите команду, чтобы узнать путь до текущей папки






Команды Linux Task 17
Таск 17
переименуйте фаил test.txt на task.txt






Команды Linux Task 18
Task 18
перейдите из папки week1 (на директорию выше)в папку makers








Команды Linux Task 19
Task 19
вы находитесь в домашней директории, с помощью какой команды вы сможете найти нужный вам файл (например test.txt)?







Команды Linux Task 20
Task 20
с помощью какой команды вы можете очистить терминал?






Команды Linux Task 21
Task 21
выведите историю использованных команд








Команды Linux Task 22
Task 22
выведите на экран содержимое текущей директории (week1)






Команды Linux Task 23
Task 23
выведите на экран скрытые файлы текущей директории (week1)









Команды Linux Task 24
Task 24
объедините содержимое файлов test1.txt и test2.txt в файл test.txt (cat filename1 filename2>filename3)









Команды Linux Task 25
Task 25
выведите в терминал объем занимаемой памяти файла test.txt







Команды Linux Task 26
Task 26
с помощью какой утилиты вы можете выполнять команды с привилегиями суперпользователя?




Команды Linux Task 27
Task 27
закройте терминал при помощи определенной команды





Команды Linux Task 28
Task 28
создайте директорию my_dir и сразу же перейдите в нее после чего создайте в ней файл my_file.py






Команды Linux Task 29
Task 29
добавьте нового пользователя в систему







Команды Linux Task 30
Task 30
выведите список переменных окружения






Команды Linux Task 31
Task 31
Какое сочетание клавиш используется для остановки определенного процесса





Команды Linux Task 32
Task 32
какая команда используется для вывода запущенных процессов








Команды Linux Task 33
Task 33
используйте последнюю введеную команду, с помощью спец символа - (!!)





Команды Linux Task 34
Task 34
добавьте новую переменную MY_VARIABLE в переменные окружения





Команды Linux Task 35
Task 35
Выведите историю последних использованных команд

и отфильтруйте вывод, найдя среди всех команд только ls












Числа. Таск 1
Объявление переменной. print( )
Переменная это именованное хранилище данных, какой-либо информации.

Каждый раз, когда мы даем значение какой-либо переменной, например:

my_string = 'Makers!' 
мы командуем нашему компьютеру предоставить место в памяти для строки 'Makers!'.

Саму переменную my_string можно представить в виде указателя на то место в памяти, где хранится строка 'Makers!'.

Таким образом, наш компьютер сможет легко найти нашу строку по указателю my_string.

Весь, описанный выше процесс в программировании называют объявлением переменной.

Посмотреть что хранится внутри перемнной, можно поместив переменную внутри функции print():

print(my_string) 
В терминале, получим значение:

Makers! 
Задание 1
Объявите переменную num со значением типа данных int и распечатайте ее








Числа. Таск 2
Типы данных.
Python является языком с динамической типизации.

Это значит что нам не нужно указывать какой тип данных может хранится в переменной.

То есть, если у нас есть переменная, в которой уже хранится число:

my_var = 42 
Мы можем легко перезаписать значение переменной с любым другим типом данных, например со списком:

my_var = ['это', 'список'] 
Распечатав переменную my_var:

print(my_var) 
Получим новое значение в виде списка:

['это', 'список'] 
Также, Python может легко понять к какому типу данных нужно отнести ту или иную информацию.

Например, если Python видит выражение в кавычках, то Python сразу знает что это строчный тип данных:

'hello' 
'42' 
"пароль@#%"
При этом кавычки могут быть как двойные, так и одинарные. Число в кавычках тоже будет являться строкой.

Задание 2
Объявите переменную word со значением типа данных str и распечатайте ее













Числа. Таск 3
Сложение и умножение чисел и строк
Для числовых типов данных в Python можно производить такие арифметические операции как сложение, вычитание, умножение, деление, возведение в степень и многие другие.

Например, можно сложить два числа и распечатать результат:

print(2 + 2) 
В терминале получим:

4 
Результат можно сохранить в переменной:

result = 10 - 5 
print(result) 
В терминале получим:

5 
Также, можно производить ариметические операции с переменными, если в них хранятся числовые значения:

num1 = 5 
num2 = 3 
result = num1 * num2 
print(result) 
Python перемножит значения в переменных num1 и num2, в итоге, в переменную result запишется:

15 
Помимо чисел, в Python можно складывать строки(в программировании склеивание строк с помощью знака +, называется конкатенацией):

print('makers' + ' ' + 'bootcamp') 
В терминале получим:

makers bootcamp 
заметьте, что пробел в кавычках ' ' тоже будет считаться за строку.

Также, можно умножить строку на число:

print('hello' * 2) 
Такое выражение, даст результат в виде:

hellohello 
Задание 3
Объявите переменные number и string.
Переменной number присвойте числовое значение (целое число от 1 до 10),
Переменной string присвойте строку (не более 10 символов).
Умножьте переменную string на number
Распечатайте результа
















Числа. Таск 4
Задание 4
Объявите две переменные x, y со значениями в виде целых чисел.
Сложите их и распечатайте результат








Числа. Таск 5
Деление чисел.
В Python существует три вида деления чисел.

Обычное деление, используется знак /:

num1 = 5 
num2 = 2 
print(num1 / num2) 
в терминале получим:

2.5 
При использовании //:

print(7 // 3) 
Python возвратит только целую часть результата, т.к 7 деленое на 3 это 2.3, целое число 2 будет результатом:

2 
Также, существует оператор %:

print(10 % 6) 
который делит одно число на другое и возвращает остаток, в число 10 помещается только одна 6, в результате остается остаток 4:

4 
Задание 5
Создайте две переменные x, y со значением типа int.
Разделите первое на второе и распечатайте результат













Типы данных. Переменные. Числа
Task 6
Даны две переменные со значением типа int. Одно положительное positive, второе отрицательное negative. Распечатайте модуль (абсолютное значение) каждой из переменной.







Числа. Таск 7
Возведение в степень.
Для возведения числа в степень, в Python используют оператор ** :

print(6 ** 2) 
получим:

36 
т.к 6 во второй степени это 6 * 6 = 36

Помимо данного оператора, существует встроенная функция pow():

print(pow(6, 2)) 
возвратит нам тот же результат:

36 
т.е pow(6, 2), равен 6 ** 2

Если мы еще передадим третье число:

print(pow(6, 2, 10)) 
то получим в терминале:

6 
т.к при наличии третьего числа, pow() возводит первое число в степень второго числа, а затем делит на третье число и возвращает остаток:

pow(6, 2, 10) равен 6 ** 2 % 10

т.к 6 ** 2 = 36, а 36 % 10 = 6, получаем результат 6

Задание 7
Создайте целое число x.
Возведите его в куб с помощью встроенной функции
Распечатайте результат.









Числа. Таск 8
Задание 8
Создать две переменные x, y со значением типа int.
Найдите остаток от деления первого на второе и распечатайте результат.








Числа. Таск 9
Задание 9
Создать целое число y.
Возведите его в квадрат и найдите остаток от деления на 5 и распечатайте результат.









Числа. Таск 10
Задание 10
Примите от пользователя 3 числа inp1, inp2, inp3 из вкладки INPUT,
Перемножьте первые два числа,
Найдите остаток от деления на третье число.
Распечатайте полученный результат.









Числа. Таск 11
Задание 11
Примите от пользователя 2 целых числа num1, num2,
Cоздайте ещё одну переменную num3 со значением типа float.
Найдите остаток от деления первых двух чисел,
Умножьте остаток на третье число
Распечатайте результат









Числа. Таск 12
Задание 12
Создать десятичное число с переменной decimal.
Найдите и распечатайте его квадрат, куб, квадратный корень.
Note: Каждое вычисление записывайте в новый принт










Числа. Таск 13
Задание 13
В переменные leg_a, leg_b запишите два числа, которые будут обозначать два катета прямоугольного треугольника .
Рассчитайте длину гипотенузы треугольника hypotenuse, воспользовавшись теоремой Пифагора.
Note: Теорема Пифагора: a ** 2 + b ** 2 = c ** 2.

Распечатайте результат











Числа. Таск 14
Модуль math.
Работая с Python, мы будем постоянно использовать встроенные или сторонние библиотеки и модули.

Библиотеки и модули это группы различных удобных функций, которые уже были написаны за нас другими программистами.

Группа функций для математических вычислений находится в модуле math.

Для того чтобы использовать модуль, его в начале нужно импортировать.

Делается это командой import:

import math 
Теперь, данный модуль доступен в нашем рабочем файле, и мы можем использовать его через ключевое слово math:

print(math.pi) 
получим число π в терминале:

3.141592653589793 
Задание 14
Задать радиус окружности в переменной radius.
Рассчитайте площадь окружности в переменной s.
Note: Для получения числа π можете воспользоваться модулем math.

Распечатайте результат










Числа. Таск 15
Множественное присваивание.
В Python можно присвоить одну перменную к другой:

a = 'переменная А' 
b = a 
print(b) 
Так как, переменная a хранит в себе значение 'переменная А', то присвоив ее к переменной b, мы просто создали еще один "указатель" на место в памяти где хранится строка 'переменная А'.

Распечатав переменную b, получим:

переменная А 
В Python, также существует такая операция как множественное присваивание.

Множественное присваивание это возможность присвоить значения сразу нескольким переменным:

a, b = 1, 2 
print(a) 
print(b) 
теперь в перемнных а и b хранятся числа:

1 
2 
Задание 15
Объявите три переменные с целочисленными значениями first, second, third.
Затем обменяйте их значения в одно действие.
Переменной first присвойте значение переменной second.
Переменной third присвойте значение переменной first.
Переменной second присвойте значение переменной third.












Числа. Таск 16
Задание 16
Дана переменная num с длиной стороны квадрата, найдите периметр и площадь, распечатайте результат в терминале










Числа. Таск 17
Задание 17
Даны переменные length, height со сторонами прямоугольника, найдите периметр и площадь, распечатайте результат в терминале










Числа. Таск 18
Задание 18
Дана переменная radius с радиусом окружности, найдите периметр и площадь окружности, результат выведите в терминал. Число pi должно быть 3.14








Числа. Таск 19
Задание 19
Даны две переменные num1 и num2 с четными числами, переумножьте первое число само на себя столько раз, сколько хранится число во второй переменной
Вторую переменную переумножьте, соответственно столько раз, сколько хранится в первой переменной, распечатайте результат в терминале







Числа. Таск 20
Задание 20
Дана переменная num с отрицательным числом, сделайте её позитивной, распечатайте результат






Числа. Таск 21
Задание 21
Дана переменная temp с температурой воздуха по фаренгейту(float), переведите это значение в температуру по Цельсию (ответ округлите до сотых),
и распечатайте результат в терминале







`	Числа. Таск 22
Задание 22
От Бишкека до Москвы расстояние составляет s = 3 738 км, вычеслите расстояние от Бишкека до Москвы в метрах,
и распечатайте результат в терминале









Числа. Таск 23
Задание 23
Дана переменная t с целочисленным значением веса муки в 255 тонн, найдите сколько это будет в граммах, килограммах, центнерах, распечатайте результат в терминале










Числа. Таск 24
Задание 24
Найдите сколько месяцев и дней пройдёт за y = 7 лет, распечатайте результат в терминале (в 1 году 365 дней)









Числа. Таск 25
Задание 25
Высота небоскрёба h = 513 метров, рассчитайте сколько будет этажей в здании, если высота одного этажа планируется в 2.7 метров, результат распечатайте в терминале









Числа. Таск 26
Задание 26
Работнику начисляли зарплату в d_salary = 2400 долларов period = 15 месяцев,
распечатайте сколько заработал за этот период работник, в сомах, курс доллара к сому использовать 84 сома к 1 доллару,
результат распечатайте в терминале













Строки. Таск 1
Индексация строк
Строка, в Python, является последовательностью символов.

Символами могут быть буквы, числа, символы @ % ^ - ) и другие и даже пробелы.

Для Python, главное чтобы последовательность была заключена в кавычки.

Для последовательностей важен порядок, то есть строки состоящие из одних и тех же символов, но в разном порядке будут совершенно разными, например строки 'кулон' и 'клоун'.

Так как, Python не понимает человеческий язык, для того чтобы запомнить порядок символов в строке, каждому символу дается порядковый номер - индекс.

Индексы в Python начинаются с нуля:

0 1 2 3 4 5 
m a k e r s 
в строке 'makers', 'm' стоит под индексом 0, 'а' под 1, 'k' под индексом 2 и.т.д.

Для того, чтобы распечатать только первые три буквы строки, мы можем указать с какого по какой индекс нам нужно обрезать строку в квадратных скобках:

my_str = 'makers' 
print(my_str[0:3]) 
получим в терминале:

mak 
Задание 1
Присвойте переменной string любую строку.
Распечатайте первый символ этой строки.








Строки. Таск 2
Индексация строк
К строкам, также можно применять обратную индексацию, к примеру у нас есть строка:

some_word = 'hello' 
Для того, чтобы вывести последний символ, мы можем сделать так:

print(some_word[4]) 
Получим:

o 
Однако, в будущем мы будем получить разные данные в переменные, например от пользователей, и эти данные могут иметь каждый раз новое значение.

Поэтому мы должны уметь пользоваться обратной индексацией:

print(my_str[-1])
-1 означает первый элемент с конца, в терминале получим:

o 
Задание 2
Присвойте переменной string любую строку.
Выведите последний символ этой строки.






Строки. Таск 3
Срезы
Срез это извлечение подстроки из строки.

Можно сказать, мы буквально режем строку на нужные нам части.

Для срезов используют индексы элементов строки:

строка[начало : конец : шаг] 
Первое число в скобках означает индекс откуда начинается срез строки.

Второе число, через двoеточие - индекс элемента списка, перед которым срез должен закончиться (т.е. сам элемент с указанным индексом не будет включен).

Также можно задать шаг - к примеру через каждые 2 символа, 3 символа и.т.д

Каждый из этих трех параметров можно пропустить:

mnt = 'kilimanjaro'  
mnt[3:]  
# получим imanjaro
 
mnt[:5] 
# получим kilim
 
mnt[::2] 
# получим klmnao
 
mnt[-5:-2] 
# получим nja 
 
mnt[::-1] 
# получим orajnamilik 
В последнем примере, шаг равный -1, возвратит нам все элементы строки в обратном порядке.

Задание 3
Задайте любую строку переменной string,
Распечатайте последние 2 символа.





Строки. Таск 4
Задание 4
Объявите переменную string со значением в виде любой строки.
Затем переверните её и распечатайте результат.
Например, если перевернуть строку:

python 
получим в результате:

nohtyp 






Строки. Таск 5
Задание 5
Объявите две переменные string1, string2 со значениями в виде любых строк.
Затем склейте их в одну строку через пробел.
Выведите получившуюся строку в терминал.
Например, если в переменных хранятся строки 'makers' и 'bootcamp', в результате получим:

makers bootcamp 
склеивание строк в программировании называется конкатенацией









Строки. Таск 6
Задание 6
Объявите переменную string со значением в виде любой строки.
Продублируйте ее 4 раза.
Распечатайте результат. Например, если в переменной string будет строка 'hey', в результате получим:
heyheyheyhey 
размножить строку можно с помощью арифметического оператора умножения









Строки. Таск 7
Задание 7
Объявите переменную string со значением в виде любой строки.
Выведите её длину в консоль.
К примеру, если в string хранится строка 'world', результат будет:

5 
для вывода длины строк, списков, словарей, множеств в Python существует встроенная функция len()








Строки. Таск 8
Методы строк.
У каждого из типов данных в Python есть ряд встроенных методов.

У строк существуют такие методы как split(), replace(), count(), isupper(), find() и.т.д.

Для того, чтобы использовать тот или иной метод, нужно указать строку к которой применяется метод, поставить точку, затем указать сам метод, а в скобки передать нужные параметры.

Например, метод replace(), принимает параметры в скобки через запятую - что заменить, чем заменить:

my_str = 'Сегодня четверг' 
new_str = my_str.replace('четверг', 'пятница') 
print(new_str)
метод replace() не изменяет саму строку, а создает новую, поэтому результат нужно присвоить новой переменной - new_str, вывод в терминал будет:

Сегодня пятница 
Задание 8
Создайте переменную string со значением 'The quick brown fox jumps over the lazy dog'.
Замените все повторения буквы o символом * и сохраните результат в новой переменной.
Распечатайте новую переменную.
Результат должен быть:

The quick br*wn f*x jumps *ver the lazy d*g








Строки. Таск 9
Методы строк.
Методы строк также можно применять сразу внутри других функций, например внутри print():

my_str = 'Ла Ла Лэнд' 
print(my_str.count('Л')) 
метод count() возвращает количество указанных в скобках подстрок в строке, т.е в нашем случае посчитал количество букв Л и возвратил результат:

3 
Задание 9
Создайте переменную string со значением в виде любой строки.
Переведите все её символы в верхний регистр.
Распечатайте результат.
К примеру, если в string у нас строка:

world 
результатом будет:

WORLD 
используйте встроенные метод upper()









Строки. Таск 10
Задание 10
Объявите переменную string со значением в виде любой строки.
Переведите все её символы в нижний регистр.
К примеру, если в string хранится строка:

БЕГИ ФОРЕСТ, БЕГИ!
результат в терминале будет:

беги форест, беги! 
используйте встроенные метод lower()






Строки. Таск 11
Задание 11
Создайте переменную string со значением в виде любой строки.
Обменяйте местами первый и последний символы и выведите результат в консоль.(ваш код должен работать со строками любой длины)
К примеру, если в string хранится строка:

Hello
результат в терминале будет:

oellH 
используйте срезы(индексацию строк) и конкатенацию(склеивание строк)




Строки. Таск 12
Задание 12
Создайте переменную hashtags в которой будет хранится строка из хештэгов, то есть слов разделенных символом #.
Разделите их в отдельные строки.
Например, если в hashtags хранится строка:

#makers#bootcamp#программирование#it#курсы
Результат должен быть:

['makers', 'bootcamp', 'программирование', 'it', 'курсы'] 
используйте методы lstrip() и split()







Строки. Таск 13
Форматирование строк.
Создавая в будущем большие проекты на Python, мы чаще всего будем получать данные извне.

Например, когда вы заходите на Facebook, сайт вас приветствует:

Добро пожаловать на Facebook, John Snow! 
Программисты Facebook не могут сидеть и вручную прописывать отдельное приветствие для каждого из двух миллиардов пользователей.

Для таких задач, важно уметь подставлять данные автоматически.

В Python для динамической подстановки данных в строки существует такой инструмент как форматирование.

Для форматирования строк используют знак f перед кавычками строки, и фигурные скобки {}, где указывается название переменной, значение которой будет использоваться в результате:

name = 'John' 
print(f'Доброе утро, {name}!') 
Python, увидев знак f, сразу узнает форматирование, и вместо переменной {name} будет автоматически подставлять любую информацию хранящуюся в переменной name, в терминале получим:

Доброе утро, John! 
Так, если значение name поменяется:

name = 'Jane' 
print(f'Доброе утро, {name}!') 
Python сам изменит строку:

Доброе утро, Jane! 
данный вид форматирования часто называют просто f-строкой, также существуют другие способы форматирования через метод .format и через оператор %

Задание 13
Создайте переменные name(имя), last_name(фамилия), age (возраст) и city(город), значения которых вы будете получать от пользователей из функции input().

Во вкладке INPUT введите значения для переменных name(имя), last_name(фамилия), age (возраст) и city(город).

С помощью f-строк выведите краткую информацию о человеке.

Например, если в перемнную name ввели значение 'Иван', в last_name - 'Пупкин', в age - 35, а в city - 'Москва',

то в терминале получим строку:

Вас зовут Иван Пупкин, Ваш возраст: 35, Вы проживаете в городе Москва










Строки. Таск 14
Задание 14
Создайте переменную string со значением в виде любой строки.
Выведите только символы с нечётными индексами при помощи срезов.
Например, если в string хранится строка:

'Makers bootcamp' 
в результате получим:

aesbocm 





Строки. Таск 15
Задание 15
Объявите переменную string со значением в виде любой строки.
Поменяйте шестую букву на K.
Например, если в переменной хранится данная строка:

'abracadabra' 
в результате получим:

abracKdabra 






Строки. Таск 16
Task 16
Объявите переменную string со значением в виде любой строки.

Переведите все её символы в противоположный регистр и распечатайте результат.

string = 'hELLO wORLD'
# Hello World
string = 'MaKerS bOOtCamP'
# mAkERs BooTcAMp







Строки. Таск 17
Task 17
Объявите переменную string со значением в виде любой строки.

Размножьте строку три раза, при этом каждое повторение должно быть на новой строке, необходимо использовать экранирование.

Необходимо использовать функцию print() один раз.

К примеру, если в string хранится строка: 'hello world'

hello world
hello world
hello world







Строки. Таск 18
Task 18
Объявите переменную string со значением в виде любой строки.

Необходимо найти индекс буквы 'e'.

Например:

string = '...Makers'
# 6
string = 'hello'
# 1





Строки. Таск 19
Task 19
Объявите переменную string со значением в виде любой строки.

Необходимо проверить начинается ли ваша строка с подстроки "Python" (Регистр должен учитываться). Вывод: True/False

Например:

string = 'python is the best'
# False
string = 'Python is the best'
# True
string = 'I love Python'
# False








Строки. Таск 20
Task 20
Объявите переменную string со значением в виде любой строки.

Проверьте состоит ли ваша строка полностью из чисел. Вывод: True/False

Напимер:

string = '123456789a'
# False
string = '123456789'
# True









Строки. Таск 21
Task 21
Объявите переменную string со значением в виде любой строки, используя пробел.

Разделите строку по разделителю (пробелу) чтобы получился список.

К примеру, если в string хранится строка: "Hello World" Вывод:

['Hello', 'World']





Строки. Таск 22
Task 22
Объявите переменную string значением которой будет input().

Выведите ее значение используя интерполяцию строк ("Hello" и значение переменной string)

К примеру, если в переменной string хранится строка: "Makers"

Вывод:

"Hello Makers"





Строки. Таск 23
Task 23
Объявите переменные string1 и string2 со значением в виде любой строки.

Выведите значение данных переменных используя интерполяцию строк.

Необходимо использовать функцию print() только один раз.

К примеру, если в string1 хранится строка "Hello",

а в переменной string2 хранится строка "World"

Вывод:

Hello World








Строки. Таск 24
Task 24
Даны две переменные string1 = "America" и string2 = "Japan".

Выведите новую строку в который будут записаны первый, средний и последний элемент двух переменных.

Необходимо использовать срезы.

Вывод:

"AJrpan".






Строки. Таск 25
Task 25
Дана переменная string, содержащая пробелы в начале и в конце. Распечатайте строку без пробелов и выведите количество символов в строке без пробелов.

Например:

string = "          Как прекрасен этот мир!   "
Вывод:

"Как прекрасен этот мир!" 23





Строки. Таск 26
Task 26
Дана переменная string, с текстом "cow loves good milk".

Замените в ней только первые две буквы o на e

Вывод:

"cew leves good milk"






Логические Выражения. Таск 1
if ... else.
С помощью условного ветвления мы можем менять поведение нашей программы, в зависимости от того соблюдено ли определенное условие или нет.

Для этого в Python существует конструкция if ... else(дословно с английского переводится как если...в остальных случаях).

Так как, мы проверяем на совпадение по условию, код написанный в качестве условия должен возвращать булево значения True либо False:

if условие возвращает True: 
     сделай это

else: 
#в противном случае 
     сделай то 
К примеру, мы разработали социальную сеть, доступ к аккаунту юзера должен быть разрешен только, если он ввел правильный пароль:

password = 'john@123'

if password == 'john@123': 
     #два знака равно сравнивают переменную password со значением 'john@123' 
     print('Добро пожаловать!') 
else: 
     print('Неверный пароль!') 
как мы видим, после else прописывать условие не нужно, код в else сработает, если условие в if код возвратит False.

Так как, пароль равен значению 'john@123', в терминале получим:

Добро пожаловать!
Задание 1
Дано число введенное пользователем в переменной number.
Если число в переменной number больше 0 вывести True, иначе False.
Для проверки кода введите число в поле во вкладке INPUT.
Например, если в number ввели число:

21 
в результате получим:

True 












Логические Выражения. Таск 2
if ... else.
После ключевого слова if, для составления условия, можно использовать встроенные функции и методы, главное чтобы выражение возвращало True или False.

Например:

my_str = 'MAYDAY'

if my_str.isupper(): 
     print('заглавные') 
else: 
     print('строчные') 
Метод строк isupper() проверяет состоит ли строка из одних заглавных букв, и возвращает True либо False.

Так как, строка my_str состоит из одних больших букв, метод возвращает True, и в результате получаем строку:

заглавные 
Задание 2
Проверить переменную string, куда попадает строка введенная пользователем.
Если длина строки больше 5 символов вывести True, иначе False.
Для проверки кода введите строку в поле во вкладке INPUT.
Например, если в string ввели:

'Here, there, and everywhere' 
результат должен быть:

True 














Логические Выражения. Таск 3
if... elif ... else.
Когда у нас есть больше чем одно условие, и каждое из условий предполагает разное поведение написанной нами программы, можно использовать ключевое слово elif.

Например:

action = 'unfollow'

if action == 'mute': 
     print('Скрыть посты пользователя') 
elif action == 'unfollow': 
     print('Вы отписались от пользователя') 
elif action == 'follow': 
     print('Вы теперь фолловите пользователя') 
else:  
     print('Такой функции не существует') 
С помощью elif, можно создавать бесконечное число условий, условие после elif также должно возвращать True либо False.

Задание 3
Проверить введенное переменную mark, куда попадает введенное пользователем значение.

Если значение mark больше или равно 90, вывести строку Отлично, Ваша оценка 5!,

Если значение больше или равно 80, вывести Здорово, Ваша оценка 4!,

Если значение больше или равно 70, вывести Хорошо, Ваша оценка 3!,

Если значение больше или равно 60, вывести Вам стоит подучить материал,

в других случаях вывести строку Вы не сдали экзамен.

Для проверки кода введите значение в поле во вкладке INPUT.

Если в mark ввели:

95 
результат будет:

Отлично, Ваша оценка 5! 














Логические Выражения. Таск 4
if... elif ... else.
Частой ошибкой является попытка заменить ключевое слово elif еще одним выражением с if.

Если попробовать написать несколько выражений с ключевым словом if, Python не выдаст нам ошибку, но мы получим код который будет работать не корректно.

Например, у нас есть переменная hour(час), и мы будем проверять открыт ли сейчас Makers Bootcamp:

hour = 8 

if hour < 9: 
     print("Makers пока закрыт") 
if hour >= 9 and hour <= 22: 
     # если переменная hour больше или равна 9 И меньше или равна 22  
     print("Добро пожаловать в Makers!") 
else:    
     # если ввели неправильное время, например 55  
     print("Не верный формат") 
На первый, взгляд проблемы возникнуть не должно, и если наша переменная hour равна 8, то мы должны получить строку из первого if - "Makers пока закрыт".

Вместо этого, запустив код, в терминале получаем:

Makers пока закрыт 
Не верный формат 
То есть, сработал и первый if и else.

Так получилось, потому что в условном ветвлении в Python должно быть только одно выражение if.

Получив сразу два if, Python начал высчитывать каждое выражение if в отдельности от другого, т.е фактически разделил наш пример так, первый if отдельно вместе с else:

hour = 8

if hour < 9: 
     print("Makers пока закрыт") 
else:    
     print("Не верный формат") 
Эта часть возвратит нам строку "Makers пока закрыт", т.к 8 меньше 9.

Затем, второй if также отдельно вместе с else:

hour = 8

if hour >= 9 and hour <= 22: 
     print("Добро пожаловать в Makers!") 
else:    
     print("Не верный формат") 
а эта часть в свою очередь, возвратит нам строку "Не верный формат", так как число 8 не подходит под условие в if.

В итоге, мы некорректно получили обе эти строки.

Поэтому важно использовать правильную структуру - одно условие в if, остальные условия в elif, и в конце выражение в else.

Задание 4
Проверить введенное пользователем число в переменной number:

Если число отрицательное вывести строку negative,

если положительное то positive,

если number равно 0 то вывести zero.

Для проверки кода введите значение в поле во вкладке INPUT.

Например, если в number число:

0 
результат будет:

zero 














Логические Выражения. Таск 5
Задание 5
Создать два целых числа x, y.
Выведите значение наименьшего из них.
Например, если в наших переменных хранятся числа 42 и 24, результат будет:

24 








Логические Выражения. Таск 6
Логические операторы AND и OR.
Для случаев когда, одно и то же действие должно совершаться сразу для нескольких условий, в Python существует логический оператор and(И).

Например:

num = -4

if num % 2 == 0 and num > 0: 
    print('число положительное, четное') 
else: 
    print('число 0, отрицательное, либо не четное') 
У нас есть два условия, которым должно отвечать число num чтобы сработал код в блоке if, num должен быть больше нуля и num должен делиться на два без остатка.

Так как, создавать два if'a неправильно, а в случае если мы напишем условия в if и elif, сработает только первый из блоков, мы можем объединить условия логическим оператором and.

При использовании оператора and, код сработает только в том случае если все части выражения возвратят True.

В нашем примере, число num -4 делится без остатка на 2, эта часть возвратит True. Однако, число отрицательное, т.е меньше нуля, вторая часть выражения возвратит False.

В результате, все выражение возвращает False и срабатывает блок else:

число 0, отрицательное, либо не четное 
Для случаев, когда код должен сработать тогда, когда хотя бы одно из условий возвращает True, существует логический оператор or(или).

Перепишем наш пример:

num = -2

if num % 2 == 0 or num > 0: 
     print('число либо положительное, либо четное') 
else: 
     print('число отрицательное и нечетное') 
Теперь, код в блоке if будет работать для всех чисел больше нуля и для всех чисел делющихся на 2 без остатка, в том числе и отрицательных.

В нашем примере не смотря на то, что -2 отрицательное число, код в if сработал, т.к как выражение num % 2 == 0 для числа -2 возвращает True.

Задание 6
Создать три целых числа x, y, z.
Выведите значение наименьшего из них.
К примеру, если в переменных у нас числа: 102, 36, 90, вывод в терминал будет

36 











Логические Выражения. Таск 7
Задание 7
Создать три целых числа в переменных x, y, z. Определите, сколько среди них совпадающих.

Программа должна вывести одно из чисел:

3 - если все числа совпадают,
2 - если два числа совпадают
0 - если все три числа разные.
Например, если в переменных у нас числа - 32, 32 и 100, вывод будет:

2 








Логические Выражения. Таск 8
Задание 8
В переменные x, y попадают числа вводимые пользователем. Проверить делится ли первое число на второе без остатка.

Программа должна вывести на экран следующую информацию:

частное - выводить в любом случае
если число делится с остатком, вывести остаток от деления
Например, если во вкладке INPUT ввести числа 675 и 23, вывод должен быть:

x не делится на y
Частное: 29
Остаток: 8
если в переменные получили числа 10 и 2, вывод должен быть

x делится на y
Частное: 5	








Логические Выражения. Таск 9
Задание 9
В переменную year попадает число-год от пользователя.
Определите, является ли год с данным номером високосным.
Если год является високосным, то выведите YES, иначе выведите NO.
Note: в соответствии с григорианским календарем, год является високосным в двух случаях: 1) если число года делится без остатка на 4 и НЕ делится на 100, 2) либо число года делится без остатка на 400.

Например, если в INPUT введен год 1996, вывод должен быть:

YES 
т.к число 1996 делится без остатка на 4, но не делится на 100









	
Логические Выражения. Таск 10
IN
С помощью ключевого слова in, в Python можно проверять, присуствует ли заданный элемент в списке.

Например, нам дан список, и нам нужно проверить есть ли в этом списке буква 'a':

list_ = ['a', 'b', 'c']

if 'a' in list_: 
     print('есть') 
else: 
     print('нет') 
if 'a' in list_ - буквально говорит, если 'a' в списке list_, то запусти код в блоке if.

В терминале получим:

есть 
Задание 10
Создайте список чисел nums и число target.
С помощью условных операторов выведите, есть ли число в этом списке, если есть выведите в консоль Да, если нет выведите Нет.
Например, если дан список [1, 15, 36, 88], а в переменной target хранится число 15, вывод будет:

Да 











Логические Выражения. Таск 11
Задание 11
В переменную num из вкладки INPUT попадает число, которое обозначает код символа по таблице ASCII(https://ru.wikipedia.org/wiki/ASCII)
Определить, является ли введенное число кодом английской буквы.
Если число является кодом буквы, вывести сообщение:

Это буква "буква"
в ином случае, вывести сообщение:

Это не буква, а символ "символ"
Например, если число num равно 43:

Это не буква, а символ "+"
Для числа 65:

Это буква "А"
найдите и используйте специальную функцию Python, возвращающую числовое значение Unicode элемента










Логические Выражения. Таск 12
Задание 12
В переменную greeting попадает строка из поля во вкладке INPUT
Если пользователь вводит Hi, то программа должна ответить Привет!.
Во всех других случаях вывести строку NO.
Пример, если в поле ввели Hi:

"Привет!"
если ввели что-то другое, например "Hello":

"NO"






Логические Выражения. Таск 13
Задание 13
Объявите переменную count, значение которой равно 0
Из вкладки INPUT в переменную number попадает строка состоящая из числа.
Проверьте строку в переменной number. Если строка number состоит из числа, то преобразуйте данную строку в числовой тип данных и запишите результат в count.
Распечатайте значение count.
Например, если ввели "0", то count перезапишется на 0:

0 
если ввели строку "5", то count будет равен:

5
если же, в INPUT ввели "10", распечатав count получим:

10






Логические Выражения. Таск 14
Задание 14
Создайте переменную lang и присвойте ей значение 'en' или 'ru' или 'de' или 'kg'
выведите сообщение в зависимости от значения lang

lang = 'en' выведет 'This is english'
lang = 'ru' выведет 'Это русский' 
lang = 'de' выведет 'Das ist Deutsch' 
lang = 'kg' выведет 'Бул кыргыз тили'







Логические Выражения. Таск 15
Задание 15
Дана строка string из 6-ти цифр записанных не через пробел.
Проверьте, что сумма первых трех цифр равняется сумме вторых трех цифр. Если это так - выведите 'да', в противном случае выведите 'нет'.








Логические Выражения. Таск 16
Задание 16
Запросите у пользователя 3 числа a, b, c. Упорядочите их в порядке возрастания.







Логические Выражения. Таск 17
Задание 17
Запросите у пользователя возраст и если этот возраст меньше 18,
то выведите сообщение:

'Доступ запрещен'
в ином случае сообщение:

'Добро пожаловать'







Логические Выражения. Таск 18
Задание 18
Запросите у позьзователя число от 1 до 12 Если число вне диапазона, выведите "Такого месяца нет"
Иначе выведите какому сезону принадлежит месяц под этим номером ("зима", "весна", "лето", "осень").










Логические Выражения. Таск 19
Задание 19
Запросите у пользователя строку
Если строка состоит только из чисел, то выведите "is digit"
Если строка состоит только из букв, то выведите "is alpha"
В остальных случаях выведите "is ASCII"






Логические Выражения. Таск 20
Задание 20
У треугольника сумма любых двух сторон должна быть больше третьей. Иначе две стороны просто "лягут" на третью и треугольник не получится.
Запросите у пользователя длины трех сторон. Программа должна определять, может ли существовать треугольник при таких длинах. Если да, то напечатать 'yes', нет - 'no'









Логические Выражения. Таск 21
Задание 21
Даны три стороны треугольника a, b, c (inputs). Определите тип треугольника с заданными сторонами.
Выведите одно из четырех слов: rectangular для прямоугольного треугольника, acute для остроугольного треугольника, obtuse для тупоугольного треугольника или impossible, если треугольника с такими сторонами не существует.







Логические Выражения. Таск 22
Задание 22
Для данного числа n (input, <100) закончите фразу “На лугу пасется...” одним из возможных продолжений: “n коров”, “n корова”, “n коровы”, правильно склоняя слово “корова”.







Логические Выражения. Таск 23
Задание 23
На уроке физкультуры тренер говорит «на первый-второй рассчитайтесь». Запросите у пользователя номер человека. Что он скажет, «первый» или «второй»?






Логические Выражения. Таск 24
Задание 24
Шахматная ладья ходит по горизонтали или вертикали. Даны две различные клетки шахматной доски, определите, может ли ладья попасть с первой клетки на вторую одним ходом.
Программа получает на вход четыре числа от 1 до 8 каждое, задающие номер столбца и номер строки сначала для первой клетки, потом для второй клетки.
Программа должна вывести YES, если из первой клетки ходом ладьи можно попасть во вторую или NO в противном случае.
Вводить в порядке x1, y1, x2, y2	





Логические Выражения. Таск 25
Задание 25
Шахматный слон ходит по диагонали. Даны две различные клетки шахматной доски, определите, может ли слон попасть с первой клетки на вторую одним ходом. Программа должна вывести YES, либо NO
Вводить в порядке x1, y1, x2, y2






Типы данных. Списки. Цикл for. Таск 1
Цикл for.
Циклом в программировании называется конструкция, с помощью которой можно многократно выполнить определенный код.

Цикл for используется для перебора итерируемых объектов - т.е, объектов которые могут состоять из нескольких элементов.

При использовании for, каждый из этих элементов отдельно будет попадать по одному в круг цикла.

Конструкция цикла for выглядит так:

for переменная in название_списка: 
     код  
После ключевого слова for, указывается переменная(любая), которая будет обозначать каждый из элементов внутри заданного списка.

Затем, ставится ключевое слово in и после указывается к какому списку применяется цикл.

К примеру:

nums = [13, 22, 15, 4, 2] 
 
for x in nums: 
     if x % 2 == 0: 
         print(x) 
цикл сделает пять кругов, т.к как в списке пять чисел, каждый круг вместо указанной переменной x будет попадать по очереди каждый из элементов цикла, т.е в начале будет проверка 13 % 2 == 0, затем 22 % 2 == 0, потом 15 % 2 == 0 и.т.д.

В результате, в терминале получим только те числа, что возвратят True выражению x % 2 == 0:

22 
4 
2 
Задание 1
Создайте список name_of_friends с именами пяти друзей.

Затем выведите эти имена по одному, обращаясь к каждому элементу списка. Например:

name_of_friends = ['hello', 'world', 'python', 'makers', 'bootcamp']
Результат:

hello
world
python
makers
bootcamp








Типы данных. Списки. Цикл for. Таск 2
Задание 2
Выберите свой любимый вид транспорта (например, мотоциклы или машины) и создайте список labels с марками этого вида транспорта.
Используя цикл for, выведите утверждения о каждом из элементов списка labels.
К примеру, если ваш список выглядит так:

['Honda', 'Kawasaki']
Вывод должен быть:

I like brand Honda 
I like brand Kawasaki








Типы данных. Списки. Цикл for. Таск 3
Индексы.
С помощью индексов, можно обращаться не только к объектам внутри списка, но и к составным элементам объектов списка.

Например, у нас есть список, состоящий из одного объекта:

my_list = ['ьечноств'] 
Переставим первый и последний элемент строки внутри списка.

Для этого, в начале нужно указать с каким именно объектом списка мы работаем. Наша строка находится под нулевым индексом, поэтому запишем:

new_str = my_list[0] 
Теперь, в переменной new_str хранится строка 'ьечноств'.

Далее, используя конкатенацию и индексы, уже самой строки, склеим новую строку:

new_str = my_list[0][-1] + my_list[0][1:-1] + my_list[0][0]  
print(new_str) 
my_list[0][-1] - в начале указали на саму строку под индексом 0, затем указали на последний элемент строки, под индексом -1 ('в')

my_list[0][1:-1] - указали на саму строку под индексом 0, затем с помощью среза вытащили элементы с индекса 1 по последний элемент под индексом -1 ('ечност')

my_list[0][0] - снова указали на саму строку под индексом 0 и на первый элемент строки, также под 0 индексом ('ь')

В результате, получим:

вечность 
Задание 3
Дан список name_of_list в котором хранится строка.

Разрежьте ее на две равные части.

Если длина строки нечетная, то длина первой части должна быть на один символ больше.

Переставьте эти две части местами, при этом каждый символ должен являться отдельной строкой.

Результат запишите в новый список new_list и выведите на экран.

Например, если список выглядит так:

['Helloworld!'] 
то, в результате получим:

['o', 'r', 'l', 'd', '!', 'H', 'e', 'l', 'l', 'o', 'w'] 
используйте условное ветвление, функции len() и list()







Типы данных. Списки. Цикл for. Таск 4
Задание 4
Создайте список list_, состоящий ровно из двух строк.
Переставьте эти строки местами.
Результат запишите в новый список new_list и выведите в консоль получившийся результат
Например, если list_ выглядит так:

['world', 'hello'] 
результат будет:

['hello', 'world'] 





Типы данных. Списки. Цикл for. Таск 5
Задание 5
Вы собираетесь на Иссык-Куль. Пока ваш чемодан пуст: suitcase = []. Однако он может вместить всего 5 вещей.

Положите 5 вещей в чемодан с помощью метода append()
Вы передумали, и решили убрать последнюю вещь. Вспомните, какой метод помогает удалить последний элемент.
Вы решили положить в чемодан другую вещь, только в первое место (т.е. по индексу 0). Вспомните метод, который ставит элементы по индексу.
Распечатать чемодан
Пример:

# положили 5 вещей 
['футболка', 'шорты', 'сланцы', 'очки', 'кепка'] 

 
#решили убрать последнюю 
['футболка', 'шорты', 'сланцы', 'очки'] 

 
#в начале, добавили новую вещь 
['панама', 'футболка', 'шорты', 'сланцы', 'очки'] 








Типы данных. Списки. Цикл for. Таск 6
Задание 6
Создать список чисел nums.
Используя цикл и метод списка, запишите все числа меньше 5 в новый список.
Результат запишите в переменную res и выведите в терминал. nums выглядит так:
nums = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
результат будет:

res = [1, 1, 2, 3]






Типы данных. Списки. Цикл for. Таск 7
Задание 7
Вы принимаете от пользователя последовательность чисел, разделенных запятой в переменную.
Создайте список list_ и кортеж tuple_ с этими числами и распечатайте их.
Для проверки, введите числа через запятую(без пробелов) в поле во вкладке INPUT.
Например, для чисел введенных как 1,2,3,4 вывод будет:

['1', '2', '3', '4'] 
('1', '2', '3', '4') 





Типы данных. Списки. Цикл for. Таск 8
Задание 8
Создайте список чисел list_.
Пройдитесь по элементам списка и преобразуйте все числа в строку.
Результат запишите в новый список new_list и выведите в терминал.
К примеру, если в list_:

 [1, 2, 3, 4, 5]
то в new_list получим:

['1', '2', '3', '4', '5']
используйте встроенную функцию str()





Типы данных. Списки. Цикл for. Таск 9
Задание 9
Создайте список чисел list_.
Переберите элементы циклом и вместо четных чисел, поставьте строку четное, а вместо нечетных нечетное.
Результат записать в новый список new_list и вывести в терминал.
К примеру, если в списке хранятся такие числа:

[1, 2, 3, 4, 5]
результат будет:

['нечетное', 'четное', 'нечетное', 'четное', 'нечетное']






Типы данных. Списки. Цикл for. Таск 10
range( )
Функция range( ) возвращает последовательность чисел до указанного числа, синтаксис выглядит так:

range(начало, конец, шаг) 
начало и шаг в данной конструкции можно опустить, в этом случае начало по умолчанию будет равно 0.

Например:

for x in range(5): 
     print(x) 
получим в терминале:

0 
1 
2 
3 
4 
указывая начало и шаг, можем например, получить каждое второе число в указанном промежутке:

for y in range(2, 15, 2): 
     print(y) 
выводом будет:

2 
4 
6 
8 
10 
12 
14 
Функция range() создает свой объект не относящийся к типам данных, с которыми мы работали:

x = range(5) 
print(type(x)) 
тип объекта созданного range:

<class 'range'>
Поэтому, если мы хотим получить от функции список или кортеж, преобразовать объект созданный range можно с помощью встроенных функций, например:

x = list(range(5)) 
print(x) 
в терминале получим:

[0, 1, 2, 3, 4] 
Задание 10
Используя функцию range() создайте список list_ из 20 произвольных чисел.
Распечатайте результат
Примерный вывод:

[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19] 








Типы данных. Списки. Цикл for. Таск 11
Задание 11
При помощи функции range() создайте список list_ из чётных чисел от 0 до 100 (включительно).
Распечатайте результат.
Примерный вывод:

[0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100] 








Типы данных. Списки. Цикл for. Таск 12
Задание 12
Создайте два списка list1, list2 со случайным набором чисел.
Объедините эти списки.
Затем, выведите сумму всех чисел в консоль.
К примеру, если в перемнных хранятся такие списки:

[11, 23, 45, 7, 9] 
[21, 4, 16, 8, 10] 
Объединив их и распечатав сумму всех чисел, получим:

154 






Типы данных. Списки. Цикл for. Таск 13
Задание 13
Написать программу, которая будет принимать от пользователя числа через запятую, без пробелов.
числа поместить в список list_ и вывести в отсортированном виде.
Числа переданные во вкладке INPUT сохраняются в строковом типе данных.

Поэтому, к примеру, для чисел 15,364,27,2 отсортированный список будет выглядеть так:

['15', '2', '27', '364'] 







Типы данных. Списки. Цикл for. Таск 14
Задание 14
Создать три числа в списке list_.
Вывести на экран yes, если среди них есть одинаковые, иначе вывести ERROR.
Например, для списка [1, 1, 3], вывод будет:

yes 
а для списка [1, 2, 3]:

ERROR 






Типы данных. Списки. Цикл for. Таск 15
Задание 15
Записать в список list_ все числа в промежутке от 54 до 9184 делящиеся на 5 без остатка.
Распечатайте результат.
Вывод должен быть:

[55, 60, 65, 70, 75, 80, 85, 90, 95, 100, 105, 110, 115, 120, 125, 130, 135, 140, 145, 150, 155, 160, 165, 170, 175, 180, 185, 190, 195, 200, 205, 210, 215, 220, 225, 230, 235, 240, 245, 250, 255, ... ... ... ... ...  ... ... ... ... ... ... , 9125, 9130, 9135, 9140, 9145, 9150, 9155, 9160, 9165, 9170, 9175, 9180] 








Типы данных. Списки. Цикл for. Таск 16
 Задание 16
Дан список целых чисел, найдите минимальное значение, не используя встренную функцию min().
Например:

list_ = [20, 10, 20, 1, 100]
Результат:

min_number = 1






Типы данных. Списки. Цикл for. Таск 17
Задание 17
Дан список с кортежами, выведите список без пустых кортежей
Например:

tuples = [(), ('ram','15','8'), (), ('laxman', 'sita')]
Результат:

cleared_tuples = [('ram','15','8'), ('laxman', 'sita')]







Типы данных. Списки. Цикл for. Таск 18
Задание 18
Запросите у пользователей 5 раз их имя и фамилию, но в списке сохраните лишь фамилию, также учтите, что у человека ФИО может состоять не только из 2 слов.
При выводе должен выходить отсортированный в алфавитном порядке список





Типы данных. Списки. Цикл for. Таск 19
Задание 19
Вам дан список из чисел, и переменная x в которой хранится число, посчитайте сколько вхождений этого числа в этом списке
Например:

list_ = [8, 6, 8, 10, 8, 20, 10, 8, 8]
number = 8





Типы данных. Списки. Цикл for. Таск 20
Задание 20
Вам дан список с числами и строками, найдите сумму чисел в этом списке не используя функцию sum()
Числа могут быть в виде строки
Все числа положительные
Все числа целые
Например:

list_ = [1, 'abcd', 3, '1', 4, 'xyz', 5, 'pqr', 7, 5, 12]
Вывод:

38









Типы данных. Списки. Цикл for. Таск 21
Задание 21
Вам дан список из строк, в которых длина строки равна 2 или более, в новый список запишите индексы тех строк, у которых первый и последний символы совпадают.
Например:

str_list = ['abc', 'xyz', 'aba', '1221']
Результат:

indexs = [2, 3]






Типы данных. Списки. Цикл for. Таск 22
Задание 22
У вас есть список со вложенными списками, выведите самый длинный список и самый короткий
Например:

lists = [[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]]
Результат:

max_list [13, 15, 17]
min_list [0]







Типы данных. Списки. Цикл for. Таск 23
Задание 23
Вам дан список, напишите код, который будет соединять в новый список элементы по n-ному шагу
Например:

step = 3
list_ = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n']







Типы данных. Списки. Цикл for. Таск 24
Задание 24
Напишите код для создания матрицы с размером 3x3
size = 3
Результат:

[[1, 2, 3], [1, 2, 3], [1, 2, 3]]






Типы данных. Списки. Цикл for. Таск 25
Задание 25
Вам дан список со словами, пользователь вводит первую букву слова, которое он ищет, ваш код должен вывести список со всеми словами начинающимися на эту букву
Например:

list_ = ['sun', 'flowers', 'rumor', 'stranger', 'adventure', 'architect', 'accompany', 'abandon', 'cartoon']
хочу найти слово начинающееся на букву 's'
Результат:

['sun', 'stranger']






Типы данных. Списки. Цикл for. Таск 26
Задание 26
Вам даны 2 списка, напишите код, который будет выводить разницу первого списка от второго и наоборот
Например:

colors1 = ["red", "orange", "green", "blue", "white"]
colors2 = ["black", "yellow", "green", "blue"]
У Вас должен быть всего один print






Типы данных. Списки. Цикл for. Таск 27
Задание 27
Вам даны 2 списка из чисел, нужно написать код, который будет выводить True, если есть хотя бы один общий элемент, в ином случае False
Например:

list1 = [1,2,3,4,5]
list2 = [5,6,7,8,9]
Результат:

True



Типы данных. Списки. Цикл for. Таск 28
Задание 28
Ван дан список, выведите числа, частота повторений которых больше или равно repeats

Например:

list_ = [4, 6, 4, 3, 3, 8, 4, 3, 4, 3, 8, 8]
repeats = 3
Результат:

res = [4, 3, 8]





Типы данных. Списки. Цикл for. Таск 29
Задание 29
Вам дан список из 3 чисел, выведите все возможные комбинации с этими числами
Например:

list_ = [1, 2, 3]
Результат:

1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1





Типы данных. Списки. Цикл for. Таск 30
Задание 30
Создайте список с 3 вложенными списками, где внутри должно быть три 0 K = 3 (количество списков и элементов)

Результат:

[[0, 0, 0], [0, 0, 0], [0, 0, 0]]






Типы данных. Списки. Цикл for. Таск 31
Задание 31
Вам дан список со строками, необходимо перевернуть эти строки, а также отсортировать по длине
Например:

colors = ["Red", "Green", "Blue", "White", "Black", "Yellow", "Orange"]
Результат:

['deR', 'eulB', 'neerG', 'etihW', 'kcalB', 'wolleY', 'egnarO']






Типы данных. Списки. Цикл for. Таск 32
Задание 32
Вам дан список с элементами, добавьте элемент, который хранится в переменной element в этот список после каждого n-ого шага
Например:

list_ = [1,2,3,4,5,6,7,8,9,0]
step = 2
element = 'A'
Результат:

[1, 2, 'A', 3, 4, 'A', 5, 6, 'A', 7, 8, 'A', 9, 0, 'A']




Типы данных. Списки. Цикл for. Таск 33
Задание 33
Вам дан список со вложенными списками, выведите тот список, у которого самая большая сумма
Например:

lists = [[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]
Результат:

[10, 11, 12]





Типы данных. Списки. Цикл for. Таск 34
Задание 34
Дан список целых чисел с повторяющимися элементами. Вам надо создать еще один список, содержащий только повторяющиеся элементы. Проще говоря, новый список должен содержать элементы, которых больше одного.
Например:

list_ = [10, 20, 30, 20, 20, 30, 40, 50, -20, 60, 60, -20, -20]
Результат:

repeated = [20, 30, -20, 60]





Типы данных. Списки. Цикл for. Таск 35
Задание 35
Вам дан список из букв, пользователь вводит 2 буквы, от какой и до какой буквы нужно соединить в одну строку, ваш код должен соединить эти буквы
Например:

chars = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
merge_from = 'a'
merge_to = 'd'
Результат:

['abcd', 'e', 'f', 'g']






Тип данных. Словари. Таск 1
Словарь. Элементы словаря.
Словарь в Python это изменяемый тип данных, который хранит данные в виде ключ: значение.

Что это значит?

Словари мы можем изменять - удалять, добавлять элементы, менять значения по ключу, полностью очищать словари и.т.д.
Создадим словарь хранящий времена года в виде ключей, а также определенную погоду в виде значений:

seasons = {'лето':'жара', 'осень':'дождь', 'весна':'солнечно'} 
Скажем в этом году, весна была дождливой, для того чтобы изменить значение элемента по ключу можем указать название словаря, затем в квадратных скобках, в кавычках указать ключ. Давайте проверим, меняем ли мы правильное значение, поместив наш код в print():

print(seasons['весна']) 
Получаем в терминале - солнечно. Изменить данное значение можно просто присвоив через знак равно новое:

seasons['весна'] = 'дождь' 
Для проверки распечатаем значение обратившись к элементу по ключу 'весна' :

print(seasons['весна']) 
В терминале выводится новое значение - дождь.

Задание 1
Создайте словарь

 a = {'x': 1, 'y': 2, 'z': 1}
и распечатайте один из ключей






Тип данных. Словари. Таск 2
Словари. Добавление и удаление элементов.
У нас есть словарь:

seasons = {'лето':'жара', 'осень':'дождь', 'весна':'дождь'} 
Попробуем добавить недостающую зиму в наш словарь, для этого существует метод словаря - update(). update() принимает в скобках новый элемент словаря, в виде

ключ : значение

который также нужно поместить в фигурные скобки - {}:

seasons.update({'зима': 'снег'}) 
Если же, мы пожалели о последнем решении и решили что зима нам не нужна, можем ее удалить с помощью метода pop(), для данного метода достаточно указать ключ элемента, который мы хотим удалить:

seasons.pop('зима') 
В случае, если мы хотим сохранить удаленный элемент для дальнейшей работы, можем присвоить выражение с pop() к какой-либо переменной:

deleted = seasons.pop('зима') 
print(deleted) 
Получим в терминале - зима

Задание 2
Объявите словарь

 a = {'a': 1, 'b': 2, 'c': 1}
удалите один из элементов и распечатайте удалённый элемент.




Тип данных. Словари. Таск 3
Задание 3
Объявите словарь

 a = {'a': 1, 'b': 2, 'c': 1}
добавьте в него новую пару ключ: значение

 {'f': 55}
специальным методом и распечатайте.




Тип данных. Словари. Таск 4
Задание 4
Объявите словарь

 a = {'a': 1, 'b': 2, 'c': 1}
удалите всего его элементы специальным методом и распечатайте словарь. Результат в терминале, должен быть такой:

{} 





Тип данных. Словари. Таск 5
Задание 5
Дан словарь

 a = {'a': 1, 'b': 2, 'c': 1}
выведите все его ключи методом словаря, то есть только a, b, c

Вывод:

['a', 'b', 'c']




Тип данных. Словари. Таск 6
Задание 6
Объявите словарь

 a = {'a': 1, 'b': 2, 'c': 1}
сделайте его копию b специальным методом и распечатайте эту копию.





Тип данных. Словари. Таск 7
Словари. Работа с циклами.
Словари в Python являются коллекциями - могут состоять из одного и более элементов. Поэтому, мы можем применять к ним циклы, или как говорят в программировании, перебирать их циклом.

Для перебора словарей очень хорошо подходит цикл for, синтаксис которого, при работе с ключами словаря будет следующим:

for переменная_ключа in название_словаря: 
     наш код  
Допустим, у нас есть словарь:

my_dict = {'name': 'Carol', 'password': 'carol123', 'group': 'Python'}  
Распечатать ключи данного словаря можно так:

for k in my_dict: 
     print(k)  
При каждом круге цикла, в переменную k подставляется каждый из ключей словаря - name, password, group.
Вывод в терминале:

name 
password 
group 
Задание 7
Дан словарь

 a = {'a': 1, 'b': 2, 'c': 1}
пройдитесь по нему циклом и распечатайте все ключи.










Тип данных. Словари. Таск 8
Словари. Работа с циклами.
В предыдущем примере, мы работали только с ключами словаря, как же можно обратиться и к ключам и к значениям словаря?
Для этого нам придется немного изменить синтаксис цикла for:

for k, v in название_словаря.items(): 
     наш код  
здесь

k - переменная для ключей словаря

v - переменная для значений словаря

.items() - метод словаря возвращающий ключи и значения каждого элемента в кортеже, которые в свою очередь будут находится в списке.

Попытка перебрать циклом и ключи и значения словаря без метода items() будет приводить к ошибке.

Используем тот же словарь:

my_dict = {'name': 'Carol', 'password': 'carol123', 'group': 'Python'}  
Попробуем применить к словарю метод .items() и распечатать его:

print(my_dict.items())  
Получим в терминале:

dict_items([('name', 'Carol'), ('password', 'carol123'), ('group', 'Python')])  
Получив элементы в таком виде, их уже можно перебрать циклом for.
Распечатаем ключи и значения словаря:

for x, z in my_dict.items(): 
     print(x, z)  
При каждом круге цикла, в переменную x подставляется каждый из ключей словаря - name, password, group, а в переменную 'z' каждое значение - Carol, carol123, Python.
Вывод в терминале:

name Carol 
password carol123 
group Python 
Задание 8
Создайте словарь

 a = {'a': 1, 'b': 2, 'c': 1}
пройдитесь по нему и распечатайте все значения








Тип данных. Словари. Таск 10
Задание 10
Дан словарь, удалите из него все элементы с пустыми значениями.

Пример:

 a = {'a': None, 'b': 1, 'c': 2, 'd': None, 'e': 3}
->

 {'b': 1, 'c': 2, 'e': 3}






Тип данных. Словари. Таск 11
Задание 11
Создайте словарь a, где ключами будут названия товаров, а значениями их цены, затем пройдитесь циклом по нему и поменяйте все значения элементов, разделив их на 5.

Ввод:

a = {'apple': 0.40, 'orange': 0.35, 'banana': 0.25} 
Вывод:

{'apple': 0.08, 'orange': 0.06999999999999999, 'banana': 0.05} 








Тип данных. Словари. Таск 12
Задание 12
Создайте словарь где ключами будут фрукты, а значением их цены. Удалите те элементы, значение которых будет чётным (специальным методом) и распечатайте результат.

Ввод:

a = {'apple': 2, 'orange': 5, 'banana': 10} 
Вывод:

{'orange': 5} 
(Должен измениться словарь a)







Тип данных. Словари. Таск 13
Задание 13
Создайте словарь, затем поменяйте местами ключи и значения. Распечайте полученный результат.

Ввод:

a = {'a': 1, 'b': 2, 'c': 3} 
Вывод:

{1: 'a', 2: 'b', 3: 'c'} 




Тип данных. Словари. Таск 14
Задание 14
Создайте словарь, где значениями будут являться числа. Найдите сумму этих значений и распечатайте результат.

Ввод:

a = {'a': 3, 'b': 2}
Вывод: 5






Тип данных. Словари. Таск 15
Задание 15
В переменные a1 , a2 , a3 создайте любые словари тремя возможными способами.




Тип данных. Словари. Таск 16
Задание 16
Создайте словарь
dict_ = {'x': 1, 'y': 2, 'z': 1}
Достаньте одно значение по ключу, используя специальный метод словарей, достающий один ключ, и распечатайте его.




Тип данных. Словари. Таск 17
Задание 17
Объявите словарь
dict_ = {'a': 1, 'b': 2, 'c': 1}
Удалите один из элементов, не используя методы словаря






Тип данных. Словари. Таск 18
Задание 18
Объявите словарь
dict_ = {'a': 1, 'b': 2, 'c': 1}
Выведите всего его элементы специальным методом и распечатайте результат.
Результат в терминале должен быть такой:

dict_items([('a', 1), ('b', 2), ('c', 3)])





Тип данных. Словари. Таск 19
Задание 19
Дан словарь:
dict_ = {'a': 32, 'b': 56, 'c': 37, 'd': 21}
Распечатайте максимальное значение в словаре.
Вывод:

56




Тип данных. Словари. Таск 20
Задание 20
Дан словарь. Распечатайте минимальное значение в словаре
dict_ = {'a': 32, 'b': 56, 'c': 37, 'd': 21}




Тип данных. Словари. Таск 21
Задание 21
Создайте словарь dict1 с числовыми значениями. Создайте новый словарь dict2, такой же как словарь dict1, но все нечетные значения замените на 1.
Пример:

Ввод ->
dict1 = {'a': 3, 'b': 4, 'c': 9, 'd': 5, 'e': 6} 
Вывод ->
dict2 = {'a': 1, 'b': 4, 'c': 1, 'd': 1,  'e': 6}






Тип данных. Словари. Таск 22
Задание 22
Дан словарь, оставьте все элементы с пустыми значениями, остальные удалите
 dict_ = {'a': None, 'b': 1, 'c': 2, 'd': None, 'e': 3}
Вывод:
{'a': None, 'd': None}






Тип данных. Словари. Таск 23
Задание 23
Дан словарь dict1, где ключами будут цены товаров, а значениями их названия, затем пройдитесь циклом по нему и поменяйте все ключи элементов, возведя их в квадрат, новые элементы запишите в словарь dict2

Ввод:

dict1 = {25: 'apple', 26: 'orange', 27: 'banana'} 
dict2 = {}
Вывод:
{625: 'apple', 676: 'orange', 729: 'banana'}







Тип данных. Словари. Таск 24
Задание 24
Дан список. Создайте словарь dict_, ключами которого будут строки из списка, а значениями их длины
list_ = ['Bootcamp', 'Makers', 'coding', 'hello']
dict_ = {}
Вывод:
{'Bootcamp': 8, 'Makers': 6, 'coding': 6, 'hello': 5}






Тип данных. Словари. Таск 25
Задание 25
Из предыдущего словаря dict_, достаньте ключ, значение которого является максимальным, если значений несколько, распечатайте каждый из них по отдельности.
dict_ = {'Bootcamp': 8, 'Makers': 6, 'coding': 6, 'hello': 5}
Вывод:
'Bootcamp'
Если будут одинаковые элементы:
dict_ = {'Makers': 6, 'coding': 6, 'hello': 5}
Вывод:
'Makers
Coding'









Тип данных. Словари. Таск 26
Задание 26
Дан словарь dict1, где ключи - числа от 1 до 5 и значения те же самые числа. Создайте словарь dict2, у которого ключи такие же как в первом словаре, а значения эти же числа, возведенные в куб
dict1 = {1: 1, 2: 2, 3: 3, 4: 4, 5: 5}
dict2 = {}
Вывод:
{1: 1, 2: 8, 3: 27, 4: 64, 5: 125}





Тип данных. Словари. Таск 27
Задание 27
Дан словарь dict_, значениями, которого являются словари, измените словарь dict_ таким образом, чтобы значения внутреннего словаря стали внешними значениями
dict_ = {'a': {'e': 32}, 'b': {'f': 36}, 'c': {'j': 37}, 'd': {'h': 21}}
Вывод:
{'a': 32, 'b': 36, 'c': 37, 'd': 21}




Тип данных. Словари. Таск 28
Задание 28
Дан словарь dict1. Создайте словарь dict2, с ключами как в словаре dict1, а значениями пусть будут произведение чисел внутренних словарей
dict1 = {'a': {'d': 1, 'e': 4}, 'b': {'f': 2, 'j': 4}, 'c': {'h': 3, 'i': 9}}
dict2 = {}
Вывод:
{'a': 4, 'b': 8, 'c': 27}



Тип данных. Словари. Таск 29
Задание 29
Дан список, состоящий из строк и чисел. Создайте словарь, ключами которого будут строки из списка, а значениями числа
list_ = ['hello', 23, 56, 'world', 928, 'Makers', 456, 'word', 223, 89, 'bootcamp', 'coding']
dict_ = {}
Вывод:
{'hello': 23, 'world': 56, 'Makers': 928, 'word': 456, 'bootcamp': 223, 'coding': 89}





Тип данных. Словари. Таск 30
Задание 30
Дан словарь dict_. Отсортируйте словарь по значениям в порядке увеличения.
Новые элементы занесите в словарь sorted_dict
dict_ = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}
sorted_dict = {}
Вывод:
{0: 0, 2: 1, 1: 2, 4: 3, 3: 4}
sorted(dict1, key=dict1.get) возвращает список ключей, значения сортируются по порядку. Оттуда мы можем создать новый отсортированный словарь.




Тип данных. Словари. Таск 31
Задание 31
Дан словарь dict_. Отсортируйте словарь по значениям в порядке уменьшения.
Новые элементы занесите в словарь sorted_dict
dict_ = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}
sorted_dict = {}
Вывод:
{3: 4, 4: 3, 1: 2, 2: 1, 0: 0}





Тип данных. Словари. Таск 32
Задание 32
Дан словарь. С помощью переменной key проверьте есть ли такой ключ в словаре.
Если есть, напечатайте строку "Key is present in the dictionary", если нет - "Key is not present in the dictionary"
dict_ = {1: 10, 2: 20, 3: 30, 4: 40, 5: 50, 6: 60}
key = input()








Тип данных. Словари. Таск 33
Задание 33
Даны 3 словаря. Объедините эти словари в 4
dict1 = {1:10, 2:20}
dict2 = {3:30, 4:40}
dict3 = {5:50, 6:60}
dict4 = {}
Вывод:
{1: 10, 2: 20, 3: 30, 4: 40, 5: 50, 6: 60}





Тип данных. Словари. Таск 34
Задание 34
Даны два списка одинаковой длины. Необходимо создать из них словарь таким образом, чтобы элементы первого списка были ключами, а элементы второго — соответственно значениями нашего словаря
list1 = [1, 2, 3, 4, 5, 6, 7]
list2 = ['one', 'two', 'three', 'four', 'five', 'six', 'seven']
dict_ = {}
Вывод:
{1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five', 6: 'six', 7: 'seven'}






Тип данных. Словари. Таск 35
Задание 35
Дан словарь. Найдите сумму значений словаря, который хранится под ключом vars, используя значение словаря, под ключом math
dict_ = {
    'math': {
        'sum': sum
    },
    'vars': {
        'a': 5,
        'b': 20,
        'c': 50
    }
}
Вывод:
75







Тип данных. Словари. Extra Task 1
Экстра задание 1
Создайте словарь с числовыми значениями. Например:

a = {'a': 10, 'b': 9, 'c': 3}
Необходимо перемножить все значения между собой и записать в переменную result. Ответ вывести в терминал:

270 






Тип данных. Словари. Extra Task 2
Экстра задание 2
Напишите код, который создает словарь следующим образом, вам дана строка, например:

string = "pythonist" 
нужно создать новый словарь, ключами которого будут буквы строки, а значениями числа, соответствующие количеству повторений данной буквы в строке.

dict_ = {"p":1, "y":1, "t":2, "h":1, "o":1, "n":1, "i":1, "s":1} 





Тип данных- множества, кортежи. Цикл while. Таск 1
Множество.
set, или множество, это изменяемая, неупорядоченная коллекция уникальных значений.

Мы уже работали с другими коллекциями - списками.
Также, как и в списках множества могут содержать в себе другие типы данных.

Множества в Python, обозначают фигурными скобками, например:

my_set = {True, 42, 16, 'makers'} 
В множестве нет порядка, поэтому мы не можем обращаться к отдельным элементам множества по индексу:

my_set = {True, 42, 16, 'makers'} 
print(my_set[1]) 
Такая запись, выведет нам ошибку:

TypeError: 'set' object is not subscriptable 
Особенностью данного типа данных является то, что во множестве хранятся только уникальные значения, т.е не повторяющиеся, даже если мы создадим множество вот так:

ones = {1, 1, 1, 1, 1} 
print(ones) 
распечатав, увидим что сохранилось только одно число, а дубликаты были удалены:

{1} 
Задание 1
Создайте множество в переменной a и распечатайте его.





Тип данных- множества, кортежи. Цикл while. Таск 2
Задание 2
Создайте множество a и выведите его длину.

Пример, для множества {'hello', 'world', 21}, результат будет:

3 






Тип данных- множества, кортежи. Цикл while. Таск 3
Задание 3
Создайте множество a.
Добавьте в него строку 'Hello world!'.
Распечатайте результат.
Пример, для множества:

{'Jane', 'Eyre', 22} 
вывод будет такой:

{'Jane', 'Eyre', 22, 'Hello world!'} 




Тип данных- множества, кортежи. Цикл while. Таск 4
Задание 4
Создайте два множества a и b.
Добавьте к множеству a множество b.
Распечатайте результат.
Для множеств {1, 2, 3} и {3, 4}, результат будет:

{1, 2, 3, 4} 




Тип данных- множества, кортежи. Цикл while. Таск 5
Задание 5
Создайте множество a и попробуйте удалить один из элементов.
Используйте такой метод, который не будет выдавать ошибку, если такого элемента нет.
Распечатайте результат.
К примеру, для множества {1, 2, 3}, попытка удалить несуществующий элемент 4, выведет то же множество:

{1, 2, 3} 




Тип данных- множества, кортежи. Цикл while. Таск 6
Задание 6
Создайте множество a и попробуйте удалить один из элементов.
Используйте такой метод, который будет выдавать ошибку KeyError, если такого элемента нет.
Распечатайте результат.
Для множества {1, 2, 3}, попытка удалить несуществующий элемент 9, выведет ошибку:

KeyError: 9 




Тип данных- множества, кортежи. Цикл while. Таск 7
Задание 7
Создайте множество a и удалите все элементы определённым методом.
Распечатайте результат.
Пример, для множества {1, False, 3}, результат будет:

set() 




Тип данных- множества, кортежи. Цикл while. Таск 8
Задание 8
Даны два множества a и b.
С помощью определенного метода или оператора, найдите пересечение множеств.
Распечатайте результат
Для множеств {4, 6, 100, -45, -6} и {4, 5, -5, -6}, результат будет:

{-6, 4} 




Тип данных- множества, кортежи. Цикл while. Таск 9
Задание 9
Создайте два множества a, b.
С помощью определенного метода или оператора найдите разницу множеств.
Распечатайте результат.
Для множеств {2, 4, 6, 50, -45, -6} и {4, 3, 5, -5, -6}, результат будет:

{2, -45, 50, 6} 



Тип данных- множества, кортежи. Цикл while. Таск 10
Задание 10
Создайте два множества в переменных a, b.
С помощью определенного метода или оператора объедините множества.
Распечатайте результат.
Например, для множеств {2, 4, 5, -45, -6} и {4, 3, 5, -5, 2}, результат будет:

{2, 3, 4, 5, -45, -6, -5} 




Тип данных- множества, кортежи. Цикл while. Таск 11
Задание 11
Создайте два множества a и b.
Если первое множество является подмножеством второго, распечатайте строку 'Подмножество!'.
К примеру, для множеств {0, 1, 2} и {0, 1, 2, 3, 34, 5, 8, 13}, вывод будет:

Подмножество! 






Тип данных- множества, кортежи. Цикл while. Таск 12
Задание 12
Создайте два множества a и b.
Если первое множество является надмножеством второго, распечатайте строку 'Надмножество!'.
К примеру, для множеств {0, 1, 2, 3, 34, 5, 8, 13} и {1, 2, 34}, вывод будет:

Надмножество! 






Тип данных- множества, кортежи. Цикл while. Таск 13
Задание 13
Роберт загадал пять чисел.

Используя методы множеств, напишите код определяющий, кто из перечисленных ниже людей угадал хотя бы одно число из загаданных Робертом.

robert = {5, 7, 11, 10, 28} 
kail = {1, 5, 14, 8, 22} 
merri = {19, 20, 3, 11, 10}
Если есть хотя бы одно число, которое угадал kail и хотя бы одно число, которое угадала merri, вывод должен быть:

"kail merri"
Если же только один из них угадал, то запринтите имя того, кто угадал

Если же никто не угадал заданное число, выведите строку:

no one
Пример:

robert = {5, 7, 11, 10, 28} 
kail = {1, 5, 14, 8, 22} 
merri = {19, 20, 3, 11, 10}
output:

"kail merri"










Тип данных- множества, кортежи. Цикл while. Таск 14
Задание 14
Четверо коллег tilek, timur, alexander, elina собрались на обед.

Но они не могут решить, где им пообедать, так как у каждого свои вкусовые предпочтения. Помогите найти им выход в данной ситуации.

Данные:

Тилек хочет покушать в "Dodo" или в "ImperiaPizza", ну или в крайнем случае "FreshBox".
Тимур хочет покушать шашлык в "OchakKebab" или рамен в "FreshBox".
Александр очень хочет вафли с "FreshBox" либо "KFC".
Элину устраивает любой из вариантов.
Для решения, создайте множества с названиями ресторанов в переменных-именах, например:

tilek = {'Dodo', 'ImperiaPizza' . . .} 
и используя методы множеств, выведите название ресторана который подходит для всех коллег.








Тип данных- множества, кортежи. Цикл while. Таск 15
Задание 15
Имеется пицца, ингредиенты которой помещены во множество ingredients.
Используйте методы множеств, чтобы проделать все действия.

Ингредиенты:

ingredients = {"cыр чеддар","грибы", "соус","шпинат"} 
Действия:

Добавьте "помидор" в данное множество.
Уберите ингредиент "колбаса" (если она есть!).
Уберите ингредиент "шпинат" (методом который вызовет ошибку если его нет).
Вместо шпината добавьте "базилик".
Замените "сыр чеддар" на "сыр моцарелла".
Распечатайте множество ingredients.









Тип данных- множества, кортежи. Цикл while. Extra Task 1
Экстра-задание 1
Создайте переменную a в которой будет хранится список из 3 пустых множеств.
От пользователя, вы получаете строку Hello world, которую надо сохранить в переменной inp1.

Также, вы получаете число, от 1 до 3, которое нужно сохранить в переменную inp2.

Число 1 соответствует первому множеству в списке a, число 2 второму, а 3 третьему.

В зависимости от переданного числа, сохраните строку в inp1, в одно из пустых множеств внутри списка a. В остальные множества добавьте строку "default value".

В конце, выведите получившийся список.

Например, если пользователь ввел Hello world и 1, то вывод:

[{'Hello world'}, {'default value'}, {'default value'}]
Для проверки кода, введите строку Hello world и число в поля во вкладке INPUT.













Тип данных- множества, кортежи. Цикл while. Extra Task 2
Создайте два множества set1 и set2 используя comprehensions.

В set1 должны хранится четные значения (в диапазоне от 0 до 10)

В set2 нечетные (в диапазоне от 0 до 10)

Так же необходимо проверить с помощью специального метода пересекаюся они или нет.

Если пересекаюся вывести Множества пересекаются!, если же нет Множества не пересекаются!










List, dictionary comprehension. Таск 1
List Comprehension
list comprehension - способ создания нового списка, на основе уже существующего, другого списка.

Синтаксис list comprehension выглядит следующим образом:

newlist = [выражение for каждый_элемент in старый_список if условие]  
Если внимательно присмотреться, можно заметить что внутри comprehension мы используем конструкцию схожую к циклу for ... in

выражение - это то в каком виде нам нужно возвращать каждый элемент нового списка

каждый_элемент - любая переменная, которая будет обозначать каждый элемент существующего списка

старый_список - список на базе которого мы создаем новый список new_list

условие - к какому условию должны соответствовать элементы старого списка чтобы они попали в новый список

Допустим, нам надо создать список из чисел от 33 до 43. Для генерации чисел можно использовать встроенную функцию range(). range() возвратит нам список от указанного первого числа до указанного второго числа:

new_list = [item for item in range(33, 44)] print(new_list)  
Данной записью, мы говорим Python, взять каждое число(item) в том же виде, как каждое число(item) из списка созданного функцией range(33,44)

Получим новый список в терминале:

[33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43]  
Заметьте, что второе число - 44 не включается в список.

Задание 1
Создайте список list_ из целых чисел от 1 до 100 (включительно). Нужно использовать comprehension.










List, dictionary comprehension. Таск 2
List Comprehension.
Теперь рассмотрим пример, где элементы списка, должны отвечать к какому-либо условию чтобы попасть в новый список.

У нас есть данный список:

nums = [0, 18, 33, 54, 87, 2, 13] 
Создадим новый список, используя comprehension, таким образом, чтобы в нем были числа больше 20.

new_nums = [n for n in nums if n > 20] 
print(new_nums) 
Здесь, указываем добавить элемент n из старого списка nums, в том же виде, не изменяя, после того как указали откуда брать эти числа из списка nums, прописываем условие что берем только те числа что возвращают True для выражения n > 20 (сравнивается каждое число - 0 > 20 --> False, 18 > 20 --> False, 33 > 20 --> True, и.т.д)

В итоге, получаем результат в терминале:

[33, 54, 87] 
Задание 2
Создайте список list_ из нечётных целых чисел в промежутке от 1 до 50. Нужно использовать comprehension.












List, dictionary comprehension. Таск 3
Задание 3
Создайте список используя

list_ = [-4, -3, -2, -1, 0, 1, 2, 3, 4]
и запишите в новый список int_list

только четные числа, которые больше нуля. Нужно использовать comprehension.






List, dictionary comprehension. Таск 4
List Comprehension.
Что если нам нужно преобразовать элементы перед тем как создавать из них новый список?

У нас есть список:

nums = [1, 2, 3, 4, 5] 
Создадим из него новый список, где каждое число из nums будет возведено в куб:

new_nums = [item ** 3 for item in nums] 
print(new_nums) 
Применяем выражение item ** 3 (1 ** 3, 2 ** 3, 3 ** 3 и.т.д) для каждого элемента item (1, 2, 3, и.т.д) старого списка nums, и указываем откуда берем числа - из списка nums.

Получаем новый список в терминале:

[1, 8, 27, 64, 125] 
Задание 4
Создайте список list_ из квадратов всех чисел от 1 до 25 (включительно). В результате, список list_ должен выглядеть так:

[1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225, 256, 289, 324, 361, 400, 441, 484, 529, 576, 625] 
Нужно использовать comprehension.






List, dictionary comprehension. Таск 5
Задание 5
Используя данный список:

str_list = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10']
создайте новый список int_list, где все элементы, строки старого списка str_list, будут преобразованы в числовой тип данных:

[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]  
Нужно использовать comprehension.





List, dictionary comprehension. Таск 6
Рассмотрим данный пример, дан список:

old_list = [-2, 5, -8, -16, 9, 58] 
На базе этого списка нужно создать новый, где все отрицательные числа будут заменены строкой 'меньше нуля'.

Простого условия, по которому должны сортироваться числа здесь не достаточно, ведь нам нужно заменить некоторые из строк. Используя тернарные операторы, мы можем переписать наше условие таким образом:

x if x > 0 else 'меньше нуля' 
То есть, мы должны оставить число (х) если оно больше нуля, в противном случае (else) заменить его строкой 'меньше нуля'.

Теперь нужно просто указать что применяем тернарный оператор для каждого элемента х списка old_list:

x if x > 0 else 'меньше нуля' for x in old_list 
Оборачиваем в квадратные скобки, присвоим переменной new_list и распечатаем результат:

my_list = [x if x > 0 else 'меньше нуля' for x in old_list] 

print(my_list) 
Получаем в терминале:

['меньше нуля', 5, 'меньше нуля', 'меньше нуля', 9, 58] 
Задание 6
Создайте список list_ из чисел от 1 до 10 (включительно), заменяя четные числа - квадратом числа(число умноженное само на себя), нечетные добавьте без изменений.

В результате должны получить:

[1, 4, 3, 16, 5, 36, 7, 64, 9, 100] 
Нужно использовать comprehension.






List, dictionary comprehension. Таск 7
Задание 7
Пройдитесь по промежутку чисел от 1 до 10 и запишите в список list_ True вместо числа, если число чётное и False вместо числа, если число нечетное.

Результат будет таким:

[False, True, False, True, False, True, False, True, False, True] 
1 - нечетное число, не делится на 2 без остатка, вместо числа записывается - False

2 - четное число, 2 деленное на 2, будет 1 без остатка, записывается - True

3 - нечетное, т.к 3 деленное на 2, даст остаток 1, значит вместо числа будет False

и так далее . . .

Нужно использовать comprehension.










List, dictionary comprehension. Таск 8
Задание 8
Создайте список из 10 произвольных имён list_name.

Затем пройдитесь по данному списку и если длина имени меньше или равна 4 буквам создайте список new_list имя на shorter, а если больше на longer.
Пример:

list_name = ['paul', 'john', 'george', 'ringo', 'eric', 'patty', 'yoko', 'cynthia', 'linda', 'jude' ] 
Вывод в терминале:

['shorter', 'shorter', 'longer', 'longer', 'shorter', 'longer', 'shorter', 'longer', 'longer', 'shorter'] 
Нужно использовать comprehension.






List, dictionary comprehension. Таск 9
Dictionary comprehension.
Синтаксис dictionary comprehension выглядит так:

my_dict = {ключ : значение for ключ in список } 
(* здесь уже используем фигурные скобки - {})

Давайте создадим словарь используя список чисел из функции range(). Список будет из пяти чисел, поэтому просто укажем range(6).

Ключами мы запишем сами числами, поэтому в начале comprehension укажем переменную num.

Значением для всех ключей, через двоеточие, запишем булево значение True:

my_dict = {num : True for num in range(6)} 
print(my_dict) 
Эта запись фактически говорит:

{num

запиши в качестве ключа все числа, попадающие в переменную num
: True

в качестве значения к каждому числу запиши True
for num

в качестве num возьми каждый элемент
in range(6)}

из списка созданного функцией range(6)

В итоге, получаем данный словарь:

{0: True, 1: True, 2: True, 3: True, 4: True, 5: True} 
Задание 9
Создайте словарь dict_ из чисел от 1 до 10, где ключами будут сами числа, а значениями их квадраты. Нужно использовать comprehension.









List, dictionary comprehension. Таск 10
Задание 10
Запросите у пользователя число от 1 до 10 в переменную n. Затем пройдитесь по промежутку чисел от 1 до 500(включительно) и запишите в словарь dict_, только те числа, которые кратны числу n (делятся на число n без остатка), введенное пользователем. Ключом будет само число, а значением его квадрат.

К примеру, пользователь ввел число:

9 
Получаем словарь:

{9: 81, 18: 324, 27: 729, 36: 1296, 45: 2025, 54: 2916, 63: 3969, 72: 5184, 81: 6561, 90: 8100, 99: 9801, 108: 11664, 117: 13689, 126: 15876, 135: 18225, 144: 20736, 153: 23409, 162: 26244, 171: 29241, 180: 32400, 189: 35721, 198: 39204, 207: 42849, 216: 46656, 225: 50625, 234: 54756, 243: 59049, 252: 63504, 261: 68121, 270: 72900, 279: 77841, 288: 82944, 297: 88209, 306: 93636, 315: 99225, 324: 104976, 333: 110889, 342: 116964, 351: 123201, 360: 129600, 369: 136161, 378: 142884, 387: 149769, 396: 156816, 405: 164025, 414: 171396, 423: 178929, 432: 186624, 441: 194481, 450: 202500, 459: 210681, 468: 219024, 477: 227529, 486: 236196, 495: 245025} 
Из списка чисел от 1 до 500, числа 9, 18, 27, 36, 45 ... и.т.д делятся на 9 без остатка, записываем их как ключи.

Значениями записываем квадраты(число умноженное само на себя ) - 81, т.к 9 х 9 = 81, 324, т.к 18 х 18 = 324, и.т.д

Нужно использовать comprehension.







List, dictionary comprehension. Таск 11
Задание 11
Дан словарь a в котором значениями являются целые числа.
 Пройдитесь по элементам и 
запишите в dict_ значения на список
 чисел от 1 до числа, которое является значением.
  Нужно использовать comprehension.

Например:

 a = {'a': 1, 'b': 5, 'c': 4, 'd': 3}
 
 -> 
 
{'a': [1], 'b': [1, 2, 3, 4, 5], 'c': [1, 2, 3, 4], 'd': [1, 2, 3]}










List, dictionary comprehension. Таск 12
Задание 12
Создайте словарь dict_ где ключами будут строки, 
а значениями произвольные числа. 
Затем пройдитесь по элементам и запишите в a вместо значения строку 
'even', если значение четное, а если нет то 'odd'.

Например, если у нас есть словарь:

dict_ = {'first': 1, 'second': 2, 'third': 3} 
То результатом будет:

{'first': 'odd', 'second': 'even', 'third': 'odd'} 
Нужно использовать comprehension.





List, dictionary comprehension. Таск 13
Задание 13
Дано предложение

 string_ = 'In 1984 there were 13 instances of a protest with over 1000 people attending'
Получите список чисел list_ из этого предложения.

Вывод будет таким:

['1984', '13', '1000'] 
Нужно использовать comprehension.





List, dictionary comprehension. Таск 14
Задание 14
Дан вложенный словарь dict_ (словарь состоящий из других словарей)
в котором ключом является имя студента, 
а значением словарь с его оценками по 3 предметам.

Распечатайте новый словарь, где вместо оценкок будет название предмета, 
по которому студент имеет высший балл. Нужно использовать comprehension.

Например:

 dict_ = {'Timur': {'history': 90, 'math': 95, 'literature': 91},
 
'Olga': {'history': 92, 'math': 96, 'literature': 81},
 
 'Nik': {'history': 84, 'math': 85, 'literature': 87}}
Результат:

 {'Timur': 'math', 'Olga': 'math', 'Nik': 'literature'}







 List, dictionary comprehension. Таск 15
Задание 15
Дан словарь my_dict значениями в котором являются другие словари.

Создайте новый словарь dict_, оставив те же ключи, но заменив значения, значениями внутренних словарей.

Например:

 my_dict = {'first': {'a': 1}, 'second': {'b': 2}} 
 dict_ = {'first': 1, 'second': 2} 
Нужно использовать comprehension.




List, dictionary comprehension. Таск 16
Задание 16
Создайте список list_ из чётных целых чисел в промежутке от 1 до 25.
Нужно использовать comprehension.



List, dictionary comprehension. Таск 17
Задание 17
Создайте список используя
list_ = [-4, -3, -2, -1, 0, 1, 2, 3, 4]
и запишите в новый список int_list числа, которые меньше нуля, замените на 1.

Нужно использовать comprehension.







List, dictionary comprehension. Таск 18
Задание 18
Из списка
list1 = [1, 2, 'hello', 3, 'world', 4, 5, 'book', 'code', 6, 'Makers', 7, 8, 9, 10]
Создайте новый list2 и внесите туда только строки из list1.

Нужно использовать comprehension.









List, dictionary comprehension. Таск 19
Задание 19
Создайте список используя
list_ = [0, 3, 9, 7, 5, 2, 18, 4]
И запишите в новый список list1 только те числа, которые больше 5.
Нужно использовать comprehension.











List, dictionary comprehension. Таск 20
Задание 20
Из списка
list_ = [False, True, False, True, False, True, False, True, False, True] 
Создайте новый. Значение True замените на 1, а False на 0.
Нужно использовать comprehension. Вывод:

[0, 1, 0, 1, 0, 1, 0, 1, 0, 1]







List, dictionary comprehension. Таск 21
Задание 21
Создайте список из 10 произвольных имён list_name.
Затем создайте список new_list, вместо имени вписав туда его длину.
Пример:

list_name = ['paul', 'john', 'george', 'ringo', 'eric', 'patty', 'yoko', 'cynthia', 'linda', 'jude' ] 
Вывод:

[4, 4, 6, 5, 4, 5, 4, 7, 5, 4]









List, dictionary comprehension. Таск 22
Задание 22
Создайте список из четных чисел в диапазоне от 1 до 1000 с шагом 125






List, dictionary comprehension. Таск 23
Задание 23
Из списка
list1 = [44,54,64,74,104]
Создайте новый list2, прибавив к каждому числу 6






List, dictionary comprehension. Таск 24
Задание 24
Из списка
list1 = [2, 4, 6, 8, 10, 12, 14]
Создайте новый, внеся туда только те числа квадрат которых больше 50







List, dictionary comprehension. Таск 25
Задание 25
Из сторки
string = "happy birthday!"
Создайте список list_, внесите туда все символы из строки кроме пробела и '!'
Вывод:

['h', 'a', 'p', 'p', 'y', 'b', 'i', 'r', 't', 'h', 'd', 'a', 'y']










List, dictionary comprehension. Таск 26
Задание 26
Дан словарь:
dict_ = {'a': {'d': 3, 'e': 45}, 'b': {'f': 23, 'j': 9}, 'c': {'h': 12, 'i': 89}}
Используйте его чтобы создать список, из значений внутренних словарей
Вывод:

[3, 45, 23, 9, 12, 89]









List, dictionary comprehension. Таск 27
Задание 27
Из списка:
list_name = ['paul', 'john', 'george', 'ringo', 'eric', 'patty', 'yoko', 'cynthia', 'linda', 'jude' ] 
Создайте словарь, занесите только те имена, длина которых больше 4. Ключами будут имена, а значениями их длины, возведенные
в квадрат.
Вывод:

{'george': 36, 'ringo': 25, 'patty': 25, 'cynthia': 49, 'linda': 25}










List, dictionary comprehension. Таск 28
Задание 28
Дан словарь
dict_ = {"Sedan": 1500, "SUV": 2000, "Pickup": 2500, "Miivan": 1600, "Vann": 2400, "Semi": 13600, "Bicycle": 7, "Motorcycle": 110}
Пройдитесь по словарю и добавьте в список только те ключи, значение,
 которых в диапазоне от 200 до 5000, добавленные в список ключи должны быть в верхнем регистре.
Нужно использовать comprehensio







List, dictionary comprehension. Таск 29
Задание 29
Дан словарь:
dict1 = {"Sedan": 1500, "SUV": 2000, "Pickup": 2500, "Miivan": 1600, "Vann": 2400, "Semi": 13600, "Bicycle": 7, "Motorcycle": 110}
Создайте словарь dict2:
Ключи должны быть те же, что и в первом словаре, но каждый символ 'i' замените на ''
Значением должно быть количество повторений символа 'i' в этом ключе
Вывод:

{'Sedan': 0, 'SUV': 0, 'Pckup': 1, 'Mvan': 2, 'Vann': 0, 'Sem': 1, 'Bcycle': 1, 'Motorcycle': 0}








List, dictionary comprehension. Таск 30
Задание 30
Из списка
list1 = [1, 2, 3, 0, None, 'a', 'abc', [], 23, [1, 2, 3, 4], '', {'a': 1, 'b': 2}, 'drf', []]
Создайте новый list2, не добавляя все пустые значения (0, None, [], {}, '')
Вывод:

[1, 2, 3, 'a', 'abc', 23, [1, 2, 3, 4], {'a': 1, 'b': 2}, 'drf']







List, dictionary comprehension. Таск 31
Задание 31
Дан список SPL_Patrons. Каждый его подсписок содержит две части информации о посетителях библиотеки:
имя посетителя
количество книг, которые они одолжили за последний год Используйте list comprehension,
 чтобы создать список readers имен меценатов, которые в прошлом году одолжили более 100 книг
SPL_Patrons = [
['Kim Tremblay', 134],
['Emily Wilson', 42],
['Jessica Smith', 215],
['Alex Roy', 151],
['Sarah Khan', 105],
['Samuel Lee', 220],
['William Brown', 24],
['Ayesha Qureshi', 199],
['David Martin', 56],
['Ajeet Patel',69]
]
Вывод:

['Kim Tremblay', 'Jessica Smith', 'Alex Roy', 'Sarah Khan', 'Samuel Lee', 'Ayesha Qureshi']









List, dictionary comprehension. Таск 32
Задание 32
Из предыдущего списка SPL_Patrons: предположим, что посетитель экономит в среднем 11,95 доллара,
 одалживая книгу вместо того, чтобы покупать ее. Используйте list comprehension, 
чтобы создать список saved_amount сэкономленной суммы для каждого клиента
Вывод:

[1601.3, 501.9, 2569.25, 1804.45, 1254.75, 2629.0, 286.79, 2378.05, 669.19, 824.55]










List, dictionary comprehension. Таск 33
Задание 33
Используйте comprehensions для создания списка из списков,
 где каждый подсписок состоит из имени пирата и стоимости его / ее награбленных мешков с зерном (рассчитайте стоимость зерна, 
 предположим, что средняя рыночная стоимость мешка зерна составляет 42 доллара, но включите только тех пиратов, которые любят попугаев)
prairie_pirates = [
['Tractor Jack', 1000, True],
['Plowshare Pete', 950, False],
['Prairie Lily', 245, True],
['Red River Rosie', 350, True],
['Mad Athabasca McArthur', 842, False],
['Assiniboine Sally', 620, True],
['Thresher Tom', 150, True],
['Cranky Canola Carl', 499, False]
]
Вывод:

[['Tractor Jack', 42000], ['Prairie Lily', 10290], ['Red River Rosie', 14700], ['Assiniboine Sally', 26040], ['Thresher Tom', 6300]]










List, dictionary comprehension. Таск 34
Задание 34
По данному ниже словарю, пройдитесь циклом
Найдите сумму лайков всех пользователей, рейтинг которых выше 3 используйте list comprehension
dict_ = {
    'Sasha': {
        'likes': 23,
        'comments': 2,
        'rating': 4
    },
    'Aliya': {
        'likes': 34,
        'comments': 5,
        'rating': 5
    },
    'Dasha': {
        'likes': 15,
        'comments': 3,
        'rating': 2
    },
    'Luna': {
        'likes': 12,
        'comments': 2,
        'rating': 1
    },
    'Rena': {
        'likes': 26,
        'comments': 7,
        'rating': 2
    }
}
Вывод:

57









List, dictionary comprehension. Таск 35
Задание 35
** Используя приведенный словарь dict_, создайте список из id, 
которые хранятся под ключом comments. Берите только те комментарии, количество которых больше 3

dict_ = {
    'Dasha': {
        'likes': 15,
        'comments': [
            {'id': 1, 'text': 'some text'},
            {'id': 2, 'text': 'some text'},
        ],
        'rating': 2
    },
    'Luna': {
        'likes': 12,
        'comments': [
            {'id': 1, 'text': 'some text'},
            {'id': 2, 'text': 'some text'},
            {'id': 3, 'text': 'some text'},
        ],
        'rating': 1
    },
    'Rena': {
        'likes': 26,
        'comments': [
            {'id': 1, 'text': 'some text'},
            {'id': 2, 'text': 'some text'},
            {'id': 3, 'text': 'some text'},
            {'id': 4, 'text': 'some text'},
            {'id': 5, 'text': 'some text'},
            {'id': 6, 'text': 'some text'},
        ],
        'rating': 2
    }
}
Вывод:

[1, 2, 3, 4, 5, 6]








List, Dict, Set comprehension. Экстра 1
Экстра задание 1
Создайте список list_ от 0 до 10 включительно c помощью специальной функции которая генерирует последовательно чисел,
отфильтруйте список оставив в нем только четные элементы,
затем разделите каждый элемент на 2 и выведите результат,
нужно работать только с одним списком, нельзя создавать доп. списки.
Необходимо использовать list comprehension
Распечатайте результат.








List, Dict, Set comprehension. Экстра 2
Экстра задание 2
Создайте словарь dict_ в котором ключами будут числа, а значениями строки. Перебирите словарь циклом:

если ключ четный, нужно заменить его значение на длину этого значения
если ключ нечетный то возвести длинну его значения в 3 степень
Распечатайте dict_.

Нужно работать только с одним словарем, нельзя создавать доп. словарь. Необходимо использовать dict comprehension.










List, Dict, Set comprehension. Экстра 3
Экстра задание 3
Создайте 2 сета set1 и set2 из 10 рандомных элементов

Затем объедините их (специальным методом) в переменную full_set,

И если их длина меньше 20, то вы должны вывести сообщение:

"В этом сете было 3 повторения, его длина составляет 17",

3 это количество элементов, которые были не уникальны,

Если же длина равна 20 то выведите сообщение "Ваш объединенный сет полностью уникальный!"

Необходимо использовать set comprehension, на этапе создания сетов.

Так же используйте генератор последовательности в comprehension чтобы создать множества из 10 элементов.

Необходимо использовать set comprehension, на этапе создания сетов.

Например после использования set comprehension в set1 храниться множество: {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}

B set2: {8, 9, 10, 11, 12, 13, 14, 15, 16, 17}

Результат работы программы будет следующий:

"В этом сете было 2 повторения, его длинна составляет 18"











Try-except. Таск 1
Задание 1
Опишите полный синтаксис конструкции try-except:








Try-except. Таск 2
Try-Except
Мы уже сталкивались с различными исключениями(ошибками) в Python - SyntaxError, 
NameError, IndexError и.т.п. При возникновении каждого из них, Python останавливает работу нашего кода.
 Для обхода данного поведения и существует конструкция try-except.

Например, мы написали код работающий со списками и ожидаем что пользователь будет запрашивать числа из списка по индексу. 
Часто, по ошибке, пользователь вводит индекс которого не существует.

Используя, try-except можем обработать ошибку IndexError и сообщить пользователю что такого индекса в списке нет:

list_ = [1, 2, 3, 4] 

try: 
    print(list_[5]) 
except IndexError: 
    print("такого индекса не существует") 
except: 
    print("что-то пошло не так") 
Элемента под индексом 5 в списке не существует, получаем в терминале сообщение:

такого индекса не существует 
Задание 2
Дан следующий код:

b = 10
c = 11
 
print(a)
Обработайте ошибку, которая может возникнуть. Если ошибок не возникло распечатайте сообщение:

Такой переменной не существует!









Try-except. Таск 3
Задание 3
Напишите программу которая будет получать два числа num1, num2 через input , и выводить результат от деления первого на второе.

Обработайте ошибку, которая возникнет в случае, если второе число окажется 0 и выведите сообщение.

К примеру, таким сообщением:

На ноль делить нельзя







Try-except. Таск 4
Задание 4
Напишите программу, которая будет получать через input 2 числа num1, num2 и будет печатать их сумму.
Обработайте ошибку, которая возникнет, если пользователь введёт что-то кроме числа и выведите сообщение, например:
Введите число!







Try-except. Таск 5
Задание 5
Создайте словарь, к примеру:

dict_ = {'key1': 'value1', 'key2': 'value2'} 
Попытайтесь вывести значение по ключу. Обработайте ошибку,
 возникающую в том случае, если такого ключа нет, например таким выводом в терминал:

Нет такого ключа!










Try-except. Таск 6
Задание 6
Создайте список list_ пример:

list_ = [1, 4, 9, 16, 25, 36] 
Обработайте исключение, возникающее при попытке обращения к несуществующему элементу. Примерный вывод в терминал:

Нет такого элемента!








Try-except. Таск 7
Try-except. Finally и Else.
После ключевого слова else можно прописать код который будет выполняться, если ошибок не возникло.

Блок finally позволяет выполнять код независимо от результата блоков try и except, т.е он сработает как в случае появления исключения,
 так и в случае корректной работы try

Рассмотрим данный пример:

x = 5  
try: 
  print(x) 
except: 
  print("что-то пошло не так") 
else: 
  print("ошибок не возникло") 
finally: 
  print("'try except' закончил свою работу") 
Так как переменная x у нас существует, наш try распечатает ее, исключение не выйдет, значит сработает также блок else, а также finally

В терминале получим вывод:

5 
ошибок не возникло 
'try except' закончил свою работу 
Задание 7
В блоке try запросите у пользователя ввод его возраста age = int(input()). Затем в том же блоке проверьте его возраст на совершеннолетие.
 Если пользователь несовершеннолетний(младше 18), выбросите исключение ValueError с текстом:

Доступ запрещён
Обработайте это исключение и другое исключение, которое возникает при вводе текста вместо возраста, выдав сообщение:

Введён некорректный возраст
Если ошибок не возникло распечатайте сообщение:

Спасибо
и, наконец, распечатайте сообщение:

До свидания!
вне зависимости от того, произошла ошибка или нет.










Try-except. Таск 8
Задание 8
В блоке try запросите у пользователя 2 числа num1, num2, затем выведите результат деления первого числа на второе.

В блоке except обработайте сразу 2 возможных исключения и распечатайте:

Произошла ошибка!






Try-except. Таск 9
Задание 9
Запросите у пользователя сумму cash которая у него сейчас есть в бумажнике. 
Если он введёт сумму, меньшую чем 0, то выбросите исключение ValueError с текстом:

Сумма не может быть отрицательной! 
иначе распечатайте сумму.








Try-except. Таск 10
Задание 10
Вам дан список list_ = [1, 2, 3], попробуйте достать элемент методом словаря get(),
 обработайте ошибку, которая может возникнуть если достать элемент таким способом








 Try-except. Таск 11
Задание 11
У вас есть переменная string, в которой хранится строка и есть переменная num, в которой хранится число, попробуйте суммировать эти переменные,
 а в случае ошибки должна выдаваться строка 
'Unsupported option', в except обработайте именно ту ошибку,
 которая возникает в этом случае, нельзя прописать просто except!








 Try-except. Таск 12
Задание 12
Добавьте числа от 0 до 10 в список list_, не создавая такой список
обработайте ошибку, которая возникнет при этом случае





Try-except. Таск 13
Задание 13
Обработайте ошибку, которая возникнет в этом коде
list_ = [1, 2, 3, 4]
for i in range(0, len(list_) + 1):
    print(list_[i])





Try-except. Таск 14
Задание 14
Создайте переменную password,
 который будет содержать пароль в виде строки.
  Вызовите исключение ValueError, если пароль меньше 6 символов





Try-except. Таск 15
Задание 15
У нас есть список warehouse (склад), куда помещается только 10 коробок.
 В каждая коробка представляет собой список, в которую помещается максимум 3 элемента.
Если на складе больше коробок, или в коробке больше элементов, чем допустимо, вызывайте ValueError
Пример склада, который не должен вызывать ошибок:

warehouse = [
    ['1', '2', '3'],
    [1, 2],
    [[1], [2], [3]],
    [[1, 2, 3], [1, 2, 3, 4, 5], {'hello': 'world'}],
]






Try-except. Таск 16
Задание 16
Напишите функцию to_fahrenheit(k:int) -> float, который будет переводить температуру из градусов Кельвина в градусы Фаренгейта. 
Ваш код должен вызывать ошибку с сообщением "Холоднее абсолютного нуля!", если пользователь ввел температуру ниже нуля или 0
Нельзя использовать условные операторы для проверки, воспользуйтесь assert
Формула (K − 273,15) × 9/5 + 32, где K - Число по Kельвину

Пояснение про AssertionError
Assertions (утверждения) — это инструкции, которые проверяют, является ли условие истинным или ложным.
В Python они выступают булевыми выражениями, если оно истинно, то программа ничего не делает и переходит к выполнению следующей строчки кода.
 Осуществляется через инструкцию assert
Например:

x = 9
y = 0
assert y != 0
print(x / y)








Try-except. Таск 17
Задание 17
Попробуйте импортировать модуль lamabimgo, если такого модуля нет, отловите ошибку и выведите сообщение Такого модуля нет








Try-except. Таск 18
Задание 18
Представьте, что у вас есть канал, где можно оставлять комментарии. 
Вам нужно написать функцию filter_comment(comment: str,
 banlist=[]) -> None, который принимает в себя сам комментарий и список запрещенных слов.
Проверьте каждое слово в комментарии, и, если оно есть в списке запрещенных слов, 
вызывать ошибку ValueError с сообщением:
"Ваш комментарий отправлен на перепроверку, так как, возможно, 
содержит неблагоприятный контекст".
Также учитывайте, что к словам могут быть прикреплены лишние символы, такие как ., !, ? и ,. Они должны будут убираться при проверке,
 регистр также не должен иметь значения.
Пример работы:

filter_comment('Hello, world', ['hello']) -> ValueError
filter_comment('HelloWorld', ['hello']) -> None
filter_comment('ochocientos ochenta y ocho') -> None
filter_comment('I love this recipe', ['hate', 'unlike', 'liken\'t']) -> None
filter_comment('Dis? recipe. is i !!UNLike!?!! really much!', ['hate', 'unlike', 'liken\'t']) -> ValueError







"""Try-except. Таск 19
Задание 19
Напишите код, который должен отрабатывать пока переменная num со значением 100000000 не будет равна 1,
 обработайте ошибку, которая может возникнуть если попытаться остановить код (ctrl+c) с сообщением Nope""""






Try-except. Таск 20
Задание 20
Напишите функцию collect_all_possibles(list_: list, num: int) -> list
Она должна принимать в себя список, и возвращать новый список, в котором будут содержаться, все возможные результаты арифметических операций на число, переданное в num, если тип данных поддерживает такую операцию (сложение, умножение, деление без остатка, вычитание, возведение в степень)
Единственное исключение - деление с остатком, его включать не нужно. Список должен быть возвращен в любом случае, даже пустым
Например:

list_ = [
    'hello',
    6, 
    [1,2,3]
]

num = 2
Выдаст

[
    'hellohello', # hello * 2
    8, # 6 + 2
    4, # 6 - 2
    12, # 6 * 2
    36, # 6 ** 2
    3, # 6 // 2
    [1, 2, 3, 1, 2, 3], # [1, 2, 3] * 2
]











Try-except. Экстра 1
Экстра задание 1
Напишите программу, которая запрашивает ввод двух значений inp1, inp2.

Если хотя бы одно из них не является числом, то должна выполняться конкатенация, т. е. соединение, строк.

В остальных случаях введенные числа суммируются.










Try-except. Экстра 2
Экстра задание 2
Запросите у пользователя несколько слов и чисел, поместите их в переменную inp1 введенных через пробел, затем:

поместите эти слова в список

переберите этот список циклом и перевидете все строки в тип данных - число


все числа поместите в отдельный list_

а на возникающие исключение сгенерируйте свое исключение cо строкой:

 Данный элемент не является числом! 










Functions. Таск 1
Функции.
Давайте рассмотрим как можно решить данное задание:

Создайте функцию, которая будет принимать 2 числа, перемножать их и возвращать результат.
Для того чтобы создать функцию используем ключевое слово def и даем нашей функции определенное имя, например mul:

def mul
По условию наша функция должна принимать два числа, значит наша функция должна иметь два параметра куда будут попадать наши числа. Определим их как x и z(в данном случае эти два параметра это просто переменные, поэтому мы можем их назвать как угодно, a и b, num1 и num2 и.т.п).

Как мы помним параметры прописываются в скобках после названия функции через запятую:

def mul(x, z):
Далее мы должны прописать логику нашей функции, а именно умножить первый параметр на второй x * z :

def mul(x, z): 
  x * z
Так как мы уже здесь можем получить конечный результат, мы можем сразу же возвратить его с помощью ключевого слова return:

def mul(x, z):      
 return x * z  
Для того чтобы проверить работу функции и увидеть результат в консоли, вызовем ее и поместим в print():

print(mul(2,3))  
В консоли увидим результат:

6 
Задание 1
Создайте функцию add, которая будет принимать 2 числа, складывать их и возвращать результат сложения.








Functions. Таск 2
Задание 2
Создайте функцию get_string_length() которая будет принимать строку. Функция должна возвращать длину этой строки.

Пример:

print(get_string_length('hello')) 
Вывод:

5 












Functions. Таск 3
Задание 3
Создайте функцию: get_type() которая принимает два обязательных параметра. Задача этой функции выводить тип принятых аргументов.

Пример:

get_type(5, 's') 
Вывод:

<class 'int'> 
<class 'str'> 
















Functions. Таск 4
Задание 4
Создайте функцию divide() которая должна принимать 2 числа и возвращать результат их деления.

Пример:

print(divide(5, 10)) 
Вывод:

0.5 










Functions. Таск 5
Функции и циклы.
Внутри функций мы также можем использовать циклы для перебора итерируемых объектов - списки, словари, множества, кортежи, строки.

Рассмотрим пример функции с циклом на данном примере:

*Создайте функцию, которая принимает список. Пройдитесь по списку циклом и распечатайте все его элементы.

Объявляем функцию с помощью ключевого слова def и даем ей название get_elems:

def get_elems 
Функция также должна принимать список в качестве параметра, назовем наш параметр my_list и поместим его в скобки:

def get_elems(my_list):
Так как мы перебираем несколько элементов в списке, мы можем использовать цикл for … in. Для цикла for … in, мы должны прописать переменную которая будет обозначать каждый из элементов в нашем списке - например element, а также указать откуда эти элементы берутся - параметр в котором хранится передаваемый список - my_list:

def get_elems(my_list):
        for element in my_list:
Теперь в переменную element будет попадать каждый объект из списка и мы можем распечатать каждый объект поместив print(element) во внутрь цикла:

def get_elems(my_list):
      for element in my_list:
          print(element)   
Запускаем нашу функцию и передаем ей в аргументы список [‘first’, ‘second’, ‘third’]:

get_elems([‘first’, ‘second’, ‘third’]) 
Получаем результат в консоли:

first 
second  
third 
Задание 5
Создайте переменную dict_ в котором будет хранится словарь.

Затем создайте функцию

def dictionary()
которая принимает этот словарь. Пройдитесь по dict_ циклом и распечатайте все его ключи внутри функции.








Functions. Таск 6
Функции. Условное ветвление.
Внутри функций также можно прописывать условия, в зависимости от которых, наша программа будет менять свое поведение.

*Создайте функцию, которая принимает один аргумент и проверяет, является ли аргумент числом или строкой.

Создаем функцию с помощью ключевого слово def, даем ей название check_type:

def check_type(): 
обозначим один параметр для функции, например под названием elem:

def check_type(elem): 
Для проверки к какому типу данных относится переданный аргумент есть специальная встроенная функция - type(). По условию нам нужно проверить, является ли наш elem строкой или числом.

Для этого используем условное ветвление if...elif...else и сравним значение возвращаемое функцией type(elem) с str для строки, int для числа и выведем соответсвтуещее сообщение:

def check_type(elem): 
 if type(elem) == str: 
     print('это строка') 
 elif type(elem) == int: 
     print('это число') 
 else: 
     print('что-то другое') 
Проверяем нашу функцию:

print(check_type(10)) 
Результат:

это число 
Задание 6
Создайте переменную num = 6. Затем создайте функцию

 check()
которая принимает переменную num в качестве аргумента

 check(num)
и возвращает "It is odd number", если это число нечетное и "It is even number" если переданное число четное.

Пример:

print(check(num)) 
Вывод:

It is even number 









Functions. Таск 7
Задание 7
Создайте функцию:

is_palindrome() 
которая будет принимать строку и проверить является ли она палиндромом.

Палиндро́м, пе́ревертень — число, буквосочетание, слово или текст, одинаково читающееся в обоих направлениях. 
Например, число 101; слова "кок", "топот", "комок" и т.д.
Функция должна возвращать True или False. Пробелы и регистр учитывать не нужно.

Пример:

print(is_palindrome('довод')) 
Вывод:

True 







Functions. Таск 8
Задание 8
Создайте функцию

max_num()
которая принимает от пользователя два числа. Она должна сравнить эти числа между собой и вернуть максимальное значение.

Пример:

print(max_num(10, 12)) 
Вывод:

12 







Functions. Таск 9
Задание 9
Создайте функцию:

multiply_list()
которая принимает список чисел и возвращает их произведение.

Пример:

print(multiply_list([1, 2, 3, 4, 5, 6])) 
Вывод:

720 







Functions. Таск 10
Задание 10
Создайте функцию

 sum_digits()
которая принимает целое число и возвращает сумму всех его цифр.

Пример:

print(sum_digits(105)) 
Вывод:

6 





Functions. Таск 11
Задание 11
Создать функцию func11, которая будет принимать 3 числа в качестве аргументов,
функция должна возвращать сумму первых двух чисел разделенную на третье число
нужно реализовать проверку на то, что третье число не является нулем, если это ноль, то просто возвратить результат сложения первого и второго числа












Functions. Таск 12
Задание 12
Создать функцию func12, которая принимает в качестве аргумента список со строками и в каком регистре нужно вернуть данные,
 строки могут быть записаны в любом регистре, задача: на основе выбора регистра,
возвращать либо список со строками в верхнем регистре, либо в нижнем регистре
Например:

func12(["hEllo", "wORld"], "lower") -> ["hello", "world"]










Functions. Таск 13
Задание 13
Создать функцию func13, которая будет принимать в качестве аргумента строку,
а затем говорить сколько в ней и каких символов, результат вернуть в виде словаря
Например:

'Hello' -> {'H': 1, 'e': 1, 'l': 2, 'o': 1}





Functions. Таск 14
Задание 14
Создайте функцию-менеджер calc, которая будет принимать в себя два числа и операцию.
Должны быть доступны операции(+, -, /, *).
Создайте также 4 доп.функции - add_, sub_, div_, mult_, которые будут принимать в себя два числа.
Затем в зависимости от операции calc будет вызывать одну из доп.функций.
Соответственно, если операция '+', то вызывается функция add_ и т.д.











Functions. Таск 15
Задание 15
Создайте функцию func15, которая будет рассылать сообщения пользователям, 
сообщая о акции в магазине компьютерной техники ("name, скидки в магазине компьютерной техники!"),
 отправлять сообщения нужно только тем людям, которые тем или иным образом относятся к IT-сфере
users = [
  { 'name': 'Jack', 'age': 35, 'work': 'IT-backend developer' },
  { 'name': 'Helen', 'age': 35, 'work': 'Nurse' },
  { 'name': 'Bob', 'age': 35, 'work': 'Driver' },
  { 'name': 'Jessica', 'age': 35, 'work': 'IT-frontend developer' },
  { 'name': 'Helga', 'age': 35, 'work': 'IT-HR' }
]
Пример:

"Jack, скидки в магазине компьютерной техники!"
"Jessica, скидки в магазине компьютерной техники!"
"Helga, скидки в магазине компьютерной техники!"










Functions. Таск 17
Задание 16
*Создать функцию func16, которая будет рассчитывать расход топлива автомобиля.
 Функция будет принимать 2 аргумента:

сколько всего километров проехали
сколько понадобилось топлива на это Затем функция должна рассчитать сколько ушло топлива на 100 км и вернуть результат вида:
 'На 100км было расходовано n-л горючего'
  Формула: топливо / расстояние затем функция должна рассчитать сколько ушло топлива на 100 км и вернуть результат вида:
'На 100км было расходовано 10л горючего'









Functions. Таск 18
Задание 17
Расчет премии сотрудникам salary - это заработная плата в месяц, overTime - количество часов, которое сотрудник взял сверхурочно,
задача: создать функцию func17, которая будет принимать и добавлять к основной зарплате сверхурочное время(1час=200$), 
функция должна принимать список со словарями и возвращать также список, но уже с измененными данными
Пример:

[{'name': 'Jack', 'salary': 10000, 'overTime': 4}] -> 
[{'name': 'Jack', 'salary': 10800}]
employees = [
  {'name': 'Jack', 'salary': 10000, 'overTime': 4},
  {'name': 'Tom', 'salary': 15000, 'overTime': 3},
  {'name': 'Jessica', 'salary': 20000, 'overTime': 9},
  {'name': 'Helen', 'salary': 25000, 'overTime': 2},
  {'name': 'Peter', 'salary': 30000, 'overTime': 7}
]








Functions. Таск 19
Задание 18
Создать функцию func18, которая в качестве аргумента будет принимать список со строками и числами,
 задача, отсортировать числа в отдельный список, а строки в отдельный и распечатать оба списка





Functions. Таск 20
Задание 19
Создайте функцию func19, которая будет в качестве аргумента принимать список такого вида как указан ниже, и будет возвращать отсортированный список (сортировать по убыванию оценок, используйте sort())
students = [
  {'student': 'Jack', 'marks': 43},
  {'student': 'Tom', 'marks': 92}, 
  {'student': 'Helen', 'marks': 85}, 
  {'student': 'Peter', 'marks': 58},
  {'student': 'Jessica', 'marks': 78}
]






Functions. Таск 21
Задание 20
Создайте функцию func20, которая будет принимать список и строку,
 а затем будет смотреть на все товары и возвращать список с теми словарями,
 у которых в названии(title) есть данная строка. Регистр учитывать не нужно

products = [
  {
    'title': 'Samsung S10', 
    'price': 800, 
    'count': 6, 
    'category': 'samsung'},
  {
    'title': 'iPhone 13 Pro', 
    'price': 1200, 
    'count': 9, 
    'category': 'apple'},
  {
    'title': 'Xiaomi Mi 10', 
    'price': 500, 
    'count': 2, 
    'category': 'xiaomi'},
  {
    'title': 'Samsung S9', 
    'price': 600, 
    'count': 4, 
    'category': 'samsung'},
  {
    'title': 'iPhone 11', 
    'price': 850, 
    'count': 1, 
    'category': 'apple'}
]
Пример:

func21(products, 'I')
Вывод:


[{'title': 'iPhone 13 Pro', 'price': 1200, 'count': 9, 'category': 'apple'},
 {'title': 'Xiaomi Mi 10', 'price': 500, 'count': 2, 'category': 'xiaomi'},
  {'title': 'iPhone 11', 'price': 850, 'count': 1, 'category': 'apple'}]











Functions. Таск 22
Задание 21
Используя
products = [
  {
    'title': 'Samsung S10', 
    'price': 800, 
    'count': 6, 
    'category': 'samsung'},
  {
    'title': 'iPhone 13 Pro', 
    'price': 1200, 
    'count': 9, 
    'category': 'apple'},
  {
    'title': 'Xiaomi Mi 10', 
    'price': 500, 
    'count': 2, 
    'category': 'xiaomi'},
  {
    'title': 'Samsung S9', 
    'price': 600, 
    'count': 4, 
    'category': 'samsung'},
  {
    'title': 'iPhone 11', 
    'price': 850, 
    'count': 1, 
    'category': 'apple'}
] 
Реализовать фильтрацию по категориям Создайте функцию func21, 
которая в качестве аргумента принимает список и строку с названием категории и возвращает список со словарями, 
где категория полностью совпадает с переданной










Functions. Таск 23
Задание 22
Создать счетчик расходов. Есть некая переменная balance, которая будет хранить данные о вашем балансе, создать две функции, первая spent будет записывать расходы, вторая deposit просто пополнять баланс.
Первая функция: ее основная задача получать 2 аргумента: на что потрачено, сколько потрачено и текущий баланс, дальше формировать словарь типа:
{'target': 'Products', 'spend': 400}
также необходимо реализовать проверку, достаточно ли средств на балансе для совершения расходов и соответственно вычитать из баланса сумму трат.
Вторая функция просто получает в качестве аргумента сумму, которую нужно добавить на баланс и сам баланс











Functions. Таск 24
Задание 23
Дан пустой список database, необходимо использовать его в качестве базы данных для словарей типа
{title: 'str', price: num, category: 'str'}
задача реализовать полный CRUD(
create(должна быть возможность создавать данные, в нашем случае объекты)
create(database, title, price, category)
read(возможность получения/чтения данных),
read(database)
update(изменение данных(можно использовать индекс)),
update(database, index, title, price, category)
delete(удаление данных(можно использовать индекс))),
delete(database, index)
за каждое действие должна отвечать отдельная функция











Scopes. Таск 1
Задание 1
Вам дана вложенная функция:

def foo():
    var = 'переменная foo'
  
    def bar():
        var = 'переменная bar'
        . . .
 
    bar()
foo()
print('переменная в foo: ', var)
Внесите изменения в функции bar таким образом чтобы при вызове функции foo и при попытке распечатать переменную 
var в глобальной области видимости, выводился следующий результат:

переменная в foo:  переменная foo
переменная в foo:  переменная bar










Scopes. Таск 2
Задание 2
У вас есть глоабльная переменная x со значением Я глобальная переменная!. 
Напишите функцию my_func()которая изменяет значение этой переменной на Я могу изменяться,
 т.е если вы после вызова функции распечатаете переменную x вне функции она должна возвращать вам значение Я могу изменяться.

Пример:

my_func()
print(x)
Output:

Я глобальная переменная!
Я могу изменяться
Затем чтобы удостовериться что вы изменили именно глобальную переменную выведите в консоль словарь глобальных имен.








Scopes. Таск 3
Задание 3
Дана глобальная переменная num со значением 3.
 Напишите функцию mul которая будет возвращать квадрат этой переменной и записывать результат в глобальную переменную num.
  Вызовите функцию три раза, и распечатайте переменную num.

mul()
mul()
mul()
print(num)
Output:

6561
тaк кaк num перезаписали на 9(3*3 = 9) затем на 81

(99 = 81) и после на 6561(8181 = 6561)








Scopes. Таск 4
Задание 4
Напишите небольшую программу для подсчета доходов и расходов.

У вас есть глобальная переменная balance = 0 общий счет.

Программа должна состоять из трех функций: get_salary(amount) - функция для увеличения баланса,
 которая принимает в аргументы amount - заработная плата и увеличивает переменную balance на число переданное в amount.

pay_bills(amount, log_name) - уменьшает баланс на количество amount ,
 log_name - принимает строку - на что были потрачены деньги и распечатывает результат, например если мы вызвали pay_bills(300, 'интернет')

функция распечатывает строку в виде

"Вы заплатили 300 сом за интернет"
И функция get_balance(), которая будет распечатывать вам строку:

У вас на счету `n` сом
где n - это текущее значение глобальной переменной balance.

Вызовите функции в данном порядке:

get_salary(1000)
get_balance()
pay_bills(400, 'кабельное тв')
get_balance()
Результат в консоли:

У вас на счету 1000 сом
Вы заплатили 400 сом за кабельное тв
У вас на счету 600 сом






Scopes. Таск 5
Задание 5
В Python есть встроенная арифметическая функция pow(),
 pow принимает два обязательных аргумента x, y и один необязательный z и возвращает результат
  в виде x**y % z - возводит первое число в степень y и если передано третье число, делит результат на третье число и возвращает остаток.

Пример использования pow:

print(pow(2,3))
# 8 - тaк кaк 2**3 = 8
print(pow(2, 3, 3))
# 2 - т.к 2**3 = 8, а остаток от деления 8 % 3 = 2
У вас есть глобальная переменная result = 0. Напишите функции pow_first(x,y),
 отвечает за первую часть встроенной функции pow и pow_second(z), отвечает за вторую часть pow(z).
  Вызовите эти функции, а затем выведите переменную result.

Пример:

pow_first(2, 3)
pow_second(3)
print(result)
Output:

2













Scopes. Таск 6
Задание 6
Мурат с друзьями на выходных решил собратся и пойти в ночной клуб.Но в ночной клуб пропускают только тех,
 кому 17+. Создайте словарь ключами которого являются имена Мурата и его друзей, а значениями являются их возраст.

 a = {'Мурат': 24, 'Эржан': 21, 'Чынгыз': 24, 'Алтынай': 17, 'Асема': 16}
Напишите программу которая определяет кого пустить в ночной клуб а кого нет.

Output:

Мурат, Вы можете войти в клуб
Эржан, Вы можете войти в клуб
Чынгыз, Вы можете войти в клуб
Алтынай, Вы можете войти в клуб
Асема, извините, Вы не проходите по age-control




Scopes. Таск 7
Задание 7
Вам дан список a из нескольких имён в нижнем регистре.
 Напишите программу которая превращает имена из списка в имена
  где первая буква имени в верхнем регистре.Запишите результат в новый список b и выведите переменную b.

Пример:

 a: ['pipi', 'papa', 'mama']
 
 b: ['Pipi', 'Papa', 'Mama']





 Scopes. Таск 8
Задание 8
Напишите функцию count_symbols() которая принимает строку и возвращает количество гласных,
 согласных букв и остальных символов. Используйте только кириллические символы. Распечатайте вызов функции.

Пример:

print(count_symbols('Мурат супер!'))
output:

Количество гласных: 4, согласных: 6, остальных символов: 2







Scopes. Таск 9
Задание 9
Создайте пустой список a. Напишите программу которая должна записывать в ваш список числа от 0 до 10. Распечатайте переменную a.






Scopes. Таск 10
Задание 10
Определите перемнную a в котором будут хранится список из целых чисел.

a = [1, 3, 4, 6, 8, 6, 8, 9, 0, 3]
Напишите функцию lower_7 которая будет возвращать список из чисел из списка a, которые меньше 7

Например:

a = [1,2,5,7,8]
print(lower_7())
[1,2,5]
Например:

a = [6,8,3,7,20]
print(lower_7())
[6,3]






Built-in. Таск 1
Встроенные функции. reduce()
Встроенная функция reduce() принимает два аргумента, функцию и последовательность.

К примеру, у нас есть данный список строк:

my_list =  [‘m’, ‘a’, ‘k’, ‘e’, ‘r’, ‘s’] 
нам нужно склеить все элементы списка в строку:

makers 
Для этого напишем функцию используя анонимную функцию lambda. Мы знаем что reduce по завершению работы возвращает нам результат в виде одного объекта и нам нужно по очереди добавить каждую букву к следующей.

В lambda мы можем указать две переменные, обозначающие каждые две буквы которые будут складываться вместе, скажем x и y:

lambda x, y 
Теперь через двоеточие указываем что нам нужно сделать с элементами в x и y, а именно сложить их через оператор +:

lambda x, y : x + y 
reduce в свою очередь будет пропускать через эту функцию все элементы в нашем списке:

lambda ‘m’, ‘a’ : ‘m’ + ‘a’ = ‘ma’

и подставлять новую строку вместо первоначальных двух:

[‘ma’, ‘k’, ‘e’, ‘r’, ‘s’]

затем снова:

lambda ‘ma’, ‘k’ : ‘ma’ + ‘k’ = ‘mak’

[‘mak’, ‘e’, ‘r’, ‘s’]

. . .

и так до тех пор пока мы не получим строку ‘makers’

Теперь, имея функцию и наш список строк мы можем применить reduce который нужно импортировать из functools:

import functools 
new_word = functools.reduce(lambda x, y: x + y, my_list) 
Выведем результат в консоль:

print(new_word) 
Получаем:

makers 
Задание 1
Дан список:

list_ = [1, 2, 3, 4]  
Выведите сумму всех этих чисел, результат сохраните в новой переменной result и выведите в консоль.

Вывод:

10 
Используйте встроенную функцию.












Built-in. Таск 2
Встроенные функции. all()
Встроенная функция all() проверяет все элементы последовательности на определенное условие
 и возвращает результат в виде булевого значения - True либо False. Например, у нас есть список:

list1 = ['THIS', 'IS', 'SOME','LIST'] 
проверим с помощью функции all и метода строк isupper, действительно ли все строки в списке в верхнем регистре:

new_list1 = all(str.isupper() for str in list1) 
print(new_list1) 
Получаем в терминале:

True 
Задание 2
Создайте переменную list_ и сохраните в нем список из чисел. Проверьте, что все числа больше трёх,
 результат сохраните в новой переменной result и выведите в консоль. Используйте встроенную функцию.

Пример:

list_ = [1, 5, -9, 6, -4] 
Вывод:

False 
Пример:

list_ = [5, 8, 4, 6, 7] 
Вывод:

True 














Built-in. Таск 3
Встроенные функции. any()
Встроенная функция any() проверяет, есть ли хотя бы один элемент в последовательности подходящий 
под определенное условие и возвращает результат в виде булевого значения - True либо False.

Например, у нас есть список:

list1 = ['some', 'string', '42'] 
проверим с помощью функции any и метода строк isdigit, есть ли в списке хотя бы одна строка состоящая из цифры:

new_list1 = any(str.isdigit() for str in list1) 
print(new_list1) 
Получаем в терминале:

True 
Задание 3
Создайте переменную list_ и сохраните в нем список из чисел. Проверьте,
 что в нём есть отрицательные числа, результат сохраните в новой переменной result и выведите в консоль.

Пример:

list_ = [5, 8, 4, 6, 7]
Вывод в терминал:

False 
Используйте встроенную функцию.

















Built-in. Таск 4
Встроенные функции. map()
map() принимает в аргументы функцию и последовательность, и применяет указанную функцию к каждому элементу последовательности.

Например, у нас есть список:

nums = [1, 2, 3, 4, 5, 6, 7] 
С помощью map возведем все числа в списке в третью степень.

В качестве функции, можем написать lambda выражение. Прописываем ключевое слово lambda, указываем переменную x, куда будет подставляться каждое из чисел в нашем списке nums. Через двоеточие, пишем что должна сделать lambda, x ** 3 ( ** - арифметический оператор возводящий в степень):

lambda x : x ** 3 
Наша функция готова, теперь передаем ее в map вместе со списком nums:

map(lambda x: x ** 3, nums) 
Оборачиваем все выражение во встроенную функцию list, чтобы преобразовать map объект в список и сохраняем в переменной new_nums(любое название):

new_nums = list(map(lambda x: x ** 3, nums)) 
print(new_nums) 
В new_nums получаем:

[1, 8, 27, 64, 125, 216, 343] 
Задание 4
Создайте переменную list_ и сохраните в нем список из чисел. Создайте новый список, состоящий из квадратов этих чисел, результат сохраните в новой переменной result и выведите в консоль.

Пример:

list_ = [1, 2, 3, 4]  
Вывод:

[1, 4, 9, 16]  
Используйте встроенную функцию.











Built-in. Таск 5
Встроенные функции. filter()
filter() принимает в аргументы выражение и последовательность,
 проходит по каждому элементу последовательности и оставляет только те элементы, которые возвращают True переданному выражению.

У нас есть список:

fruits = ['apple', 'banana', 'grapes', 'apricot'] 
Отфильтруем список и оставим в нем только те слова которые начинаются на букву а.

В качестве функции используем lambda, обозначим переменную word для каждого слова в нашем списке:

lambda word 
через двоеточие прописываем условие, так как в нашей переменной word будет хранится строка, 
и нам нужно отобрать только те строки которые начинаются с буквы a, мы можем применить строковый метод startswith:

lambda word : word.startswith('a') 
Теперь, в нашу переменную word, по одному будет попадать каждая наша строка из fruits и если word.startswith(‘a’) будет возвращать True то данные слова будут отбираться из списка таким образом:

lambda ‘apple’ : ‘apple’.startswith('a') → True

отбираем в наш новый список

lambda ‘banana’ : ‘banana’.startswith('a') → False

убираем, т.к возвратил False

Функция у нас готова, последовательность fruits есть, можем подставить аргументы в filter:

filter(lambda x: x.startswith('a') , fruits) 
Теперь преобразуем filter объект в список с помощью встроенной функции list и сохраним отфильтрованный список в новой переменной a_words:

a_words = list(filter(lambda word : word.startswith('a') , fruits))  
print(a_words) 
Получаем в терминале:

['apple', 'apricot'] 
Задание 5
Создайте переменную list_ и сохраните в нем список из чисел. Отфильтруйте этот список, оставив только чётные числа, результат сохраните в новой переменной result и выведите в консоль.

Пример:

list_ = [1, 2, 3, 4] 
Вывод:

[2, 4] 
Используйте встроенную функцию.













Built-in. Таск 6
Задание 6
Создайте переменную list_ и сохраните в нем список со строками. Отфильтруйте этот список, оставив только те строки, длина которых больше 7 символов. Результат сохраните в новой переменной result и выведите в консоль.

Пример:

list_ = ['inheritance', 'solid', 'polymorphism', 'dry', 'yagni',] 
Вывод:

['inheritance', 'polymorphism'] 












Built-in. Таск 7
Встроенные функции.
Задание 7
Создайте переменную list_ и сохраните в нем список из чисел. Выведите произведение всех этих чисел. Результат сохраните в новой переменной result и выведите в консоль. Используйте библиотеку reduce.
Пример:

list_ = [5, 6, 7, 8] 
Вывод:

1680 














Built-in. Таск 8
Встроенные функции.
Задание 8
Создайте переменную list_ и сохраните в нем список из чисел. Посчитате количество чётных и нечётных чисел в этом списке в переменных list2 и list3. Результат сохраните в новой переменной result и выведите в консоль в виде строки:

even: количество_четных, odd: количество_нечетных

Пример:

list_ = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ] 
Вывод:

even: 5, odd: 5 
Используйте встроенную функцию.











Built-in. Таск 9
Встроенные функции.
Задание 9
Создайте переменную list_ и сохраните в нем список из чисел. Если число в списке меньше 0, замените его на False, если больше, то на True. Результат сохраните в новой переменной result и выведите в консоль.

Пример:

list_ = [-1, 2, 3, 5, -3, 7] 
Вывод:

[False, True, True, True, False, True] 
Используйте встроенную функцию.












Built-in. Таск 9
Встроенные функции.
Задание 9
Создайте переменную list_ и сохраните в нем список из чисел. Если число в списке меньше 0, замените его на False, если больше, то на True. Результат сохраните в новой переменной result и выведите в консоль.

Пример:

list_ = [-1, 2, 3, 5, -3, 7] 
Вывод:

[False, True, True, True, False, True] 
Используйте встроенную функцию.








Built-in. Таск 11
Задание 11
Напишите функцию, которая будет проходить по диапазону чисел от 1 до 50. Если число кратно 3 выведите Fizz, в остальных случаях Buzz.

Результат запишите в переменную result












Built-in. Таск 12
Задание 12
Создайте переменную list_ и сохраните в ней список с числами. Найдите максимальное число из списка встроенной функцией.
Результат распечатайте в терминал











Built-in. Таск 13
Задание 13
Создайте переменную list_ и сохраните в ней список с числами. Найдите минимальное число из списка встроенной функцией.

Используйте встроенную функцию reduce. Результат распечатайте в терминал










Built-in. Таск 14
Задание 14
Создайте переменную string и сохраните в ней строку. Пройдитесь по ней и выведите индексы символов. Используйте встроенную функцию enumerate.
Результат распечатайте в терминал
Пример:

string = 'hello'
Вывод:

((0, 'h'), (1, 'e'), (2, 'l'), (3, 'l'), (4, 'o'))







Built-in. Таск 15
Задание 15
Есть последовательность из чисел list_. Верните абсолютное значение каждого числа в виде списка
Пример

list_ = [-7, -2, 12, 32, 432, 23, 37, 11, 76, 0, -23, 45, -32, -56]
Вывод

[7, 2, 12, 32, 432, 23, 37, 11, 76, 0, 23, 45, 32, 56]









Built-in. Таск 16
Задание 16
В переменной list_ хранится список с разными типами данных, выведите тип данных элементов последовательности в виде списка.
Используйте встроенную функцию
Пример:

list_ = ['hello', 123]
Вывод:

[<class 'str'>, <class 'int'>]





Built-in. Таск 17
Задание 17
Напишите переменную names, которая хранит имена студентов. Если длина имени студента больше 5, добавьте к нему Python, иначе добавьте JavaScript.

Используйте встроенную функцию

Пример:

names = ['rauchel','john','peter','jessica','steven123','dandy34','kamest','potter']
Вывод:

['rauchel Python', 'john JavaScript', 'peter Python', 'jessica Python', 'steven123 Python', 'dandy34 Python', 'kamest Python', 'potter Python']











Built-in. Таск 18
Задание 18
Напишите программу, которая будет проверять валидность почты. Проверьте, чтобы почта заканчивалась на '@gmail.com'.
Если почта заканчивается на что-то другое, то выведите 'Not valid email'
Используйте встроенные функции
Пример:

list_ = ['123hello@gmail.com', '123', 'hello']
Вывод:

['123hello@gmail.com', 'Not valid email', 'Not valid email']










Built-in. Таск 19
Задание 19
Создайте переменную string и сохраните в ней строку. Пройдитесь по ней и выведите индексы символов, начиная с 1.
Используйте встроенную функцию enumerate
Пример:

string = 'hello'
Вывод:

((1, 'h'), (2, 'e'), (3, 'l'), (4, 'l'), (5, 'o'))







Built-in. Таск 20
Задание 20
Создайте 2 списка, список list1, который содержит в себе строки и list2, который содержит в себе числа.
list1 = ['M', 'A', 'K', 'E', 'R', 'S'] 
list2 = [236, 54, 33, 21, 89, 1]
Соедините их в данный вид:

[('M', 236), ('A', 54), ('K', 33), ('E', 21), ('R', 89), ('S', 1)]
Используйте встроенную функцию zip







Built-in. Таск 21
Задание 21
Напишите переменную list_, в которой будут храниться произвольные числа.
Отфильтруйте в разные списки отрицательные и положительные числа. И соедините эти два списка.
Используйте встроенные функции
Пример:

list_ = [-7, -2, 12, 32, 432, 23, 37, 11, 76, 0, -23, 45, -32, -56]
Вывод:

[(12, -7), (32, -23)]



Built-in. Таск 22
Задание 22
Дан список:
list_ = [0.334, 23.3443, 43.4, -13.44, 22.03, -11.033, 267.993, -3.24]
Используя встроенную функцию внесите квадрат каждого числа округленный до 3х знаков в новый список.




Built-in. Таск 23
Задание 23
Дана последовательность list_, состоящая из строк. Проверьте, является ли последовательность палиндромом.
 Используйте встроенную функцию и выведите в консоль.
Пример:

list_ = ['a', 'n', 'n', 'a']
Вывод:

YES







Files. Таск 1
Работа с файлами.
(задание №1 найдете ниже)

К примеру, нам дана такая задача:

создайте файл text.txt. Запишите в него 10 любых чисел в столбик, затем считайте этот же файл и выведите первые 3 числа в консоль.

Для того чтобы нам не пришлось отдельно закрывать файл, воспользуемся командой with. Для открытия файла используем функцию open, передадим ей название файла text.txt и режим работы - w+, т.е запись и чтение. Также, обозначим открытый файл переменной file:

with open('text.txt', 'w+') as file: 
Так как, нам нужно записать не одну строку, а сразу 10( числа также записываем в строковом формате, т.е в кавычках - ‘1’, ‘2’ …) используем метод writelines для переменной file и передаем в аргументы список состоящий из чисел в строковом формате:

file.writelines(['1', '2', '3', '4', '5', '6', '7', '8', '9', '10']) 
Однако, если мы просто передадим строки, метод writelines запишет их все вместе, а нам нужно чтобы каждый элемент был на новой строке, для это воспользуемся знаком переноса строки - \n:

file.writelines(['1', '\n2', '\n3', '\n4', '\n5', '\n6', '\n7', '\n8', '\n9', '\n10']) 
Эта запись означает, что 1 у нас стоит на первой строке, перед 2 нужен перенос на новую строку поэтому мы ставим \n перед числом 2 и.т.д

Теперь нам нужно вывести в консоль первые три числа, вспоминаем что метод readlines может вывести содержимое всего файла в виде списка. А получив список строк из файла мы можем пройтись циклом и вывести первые 3 числа. Для этого напишем цикл for, обозначим каждую строку переменной line, а списком который мы будем перебирать циклом будет список возвращаемой функцией file.readlines():

for line in file.readlines(): 
Нам нужно вывести только первые три числа, и мы помним что каждый перенос строки мы обозначили символом переноса строки \n, ['1', '\n2', '\n3' . . .] - если мы посчитаем во сколько символов помещается запись трех чисел, то получим цифру 5, передадим пятерку в аргументы нашей функции readlines:

for line in f.readlines(5): 
в переменную line, при каждом круге цикла попадает наша строка из файла, можем распечатать ее с помощью print:

print(line) 
Получаем результат в консоли:

1 
2 
3 
Задание 1
Откройте файл task1.txt. В нём записаны числа от 1 до 10 в столбец. Выведите первые 5 элементов в вашем файле в терминал

Примерный вывод:

1 
2 
3 
4 
5 
(Подсказка: используйте метод для построчного считывания).










Files. Таск 2
Задание 2
Откройте файл task2.txt. В нём записаны числа от 1 до 10 в столбец. Распечатайте все числа, не используя методы.

Вывод в терминале должен быть:

1 
2 
3 
4 
5 
6 
7 
8 
9  
10 





Files. Таск 3
Задание 3
Откройте файл task3.txt в режиме записи. Запишите в него числа от 0 до 9 через символ *. Затем вернитесь в начало файла и распечатайте записанные числа. Вывод должен быть:

0*1*2*3*4*5*6*7*8*9* 









Files. Таск 4
Задание 4
Откройте файл task4.txt. В нём в нескольких строках записан текст. Прочтите содержимое и распечатайте количество строк.

К примеру, если там записано:

Hey there, Delilah

What's it like in New York city?

I'm a thousand miles away

But, girl, tonight you look so pretty

Yes, you do

Выводом будет:

5 




Files. Таск 5
Задание 5
Откройте файл task5.txt. В нём записаны целые числа. Прочтите эти числа, затем найдите максимальное затем минимальное число. Затем запишите эти числа в новый файл task6.txt через символ - (сначала минимальное, потом максимальное)

В task5.txt записаны:

45 
21 
67 
291 
13 
45 
166 
12 
1 
456 
86 
42 
45 
12 
90
В файле task6.txt должна быть такая запись:

1-456 










Files. Таск 6
Задание 6
Напишите функцию read_last(lines: int, filename: str),
 которая будет открывать определенный файл с именем filename и выводить в терминал строки,
  начиная с последней, в количестве lines.
Обратите внимание на ситуацию, в которой строк может быть больше,
 чем указано в lines, если их больше, просто выведите все строки,
  начиная с последней Для проверки вам дан файл «article.txt».







  Files. Таск 7
Задание 7
Вам дан файл article.txt
Требуется реализовать функцию longest_words(filename: str),
 которая выводит слово, имеющее максимальную длину (или список слов,
  если таковых несколько).







  Files. Таск 8
Задание 8
Требуется создать csv-файл «rows_300.csv» со следующими столбцами:
№ - номер по порядку (от 1 до 300);
Секунда – текущая секунда на вашем ПК;
Микросекунда – текущая миллисекунда на часах.
На каждой итерации цикла искусственно приостанавливайте скрипт на 0,01 секунды. (используйте модуль time)
Пример готового файла - rows_300_example.csv










Files. Таск 9
Задание 9
При помощи библиотеки Pillow в директории 
circles нарисуйте и сохраните от 5 до 15 кругов случайных цветов в формате png на белом фоне 
(каждый круг - отдельный файл).
Модуль pillow уже установлен, только случайным образом генерировать цвета в палитре RGB и воспользоваться классами Image,
 ImageDraw из установленной библиотеки.
 Чтобы нарисовать круг, нужно применить метод ellipse() и задать координаты точек, соответствующие квадрату.


 from PIL import Image, ImageDraw 






Files. Таск 10
Задание 10
Имеется текстовый файл prices.txt с информацией о заказе из интернет магазина. 
В нем каждая строка с помощью пробелов разделена на три колонки:
наименование товара;
количество товара (целое число);
цена (в рублях) товара за 1 шт. (целое число).
Напишите функцию calc_price(filename: str) -> int, возвращающую общую стоимость заказа.






Files. Таск 11
Задание 11
Имеется файл data.csv, содержащий информацию в csv-формате. Напишите функцию read_csv(filename: str) -> Dict[str, List[str]] 
для чтения данных из этого файла. Она должна возвращать словарь
Ключи в словаре - первый элемент строки
Значения - список из последующих элементов строки:
Ожидаемый вывод:

{
    '1' : ['2', '3', '4'],
    'hello' : ['world', 'makers', 'bootcamp'],
    '10': ['20', '30', '40'],
    'Python': ['JavaScript', 'Java', 'C'],
}





Files. Таск 12
Задание 12
Напишите функцию filter_text(text_filename: str) -> str, которая считывает текст с файла bad_text.txt
Возвращает содержимое этого файла, заменяя все запрещенные слова звездочками * (количество звездочек равно количеству букв в слове). Запрещенные слова, разделенные символом пробела, хранятся в текстовом файле forbidden_words.txt.
Все слова в этом файле записаны в нижнем регистре. Программа должна заменить запрещенные слова, где бы они ни встречались, даже в середине другого слова.
Замена производится независимо от регистра: если файл forbidden_words.txt содержит запрещенное слово exam, то слова exam, Exam, ExaM, EXAM и exAm должны быть заменены на ****.
Ожидаемый вывод:

*****, ***ld! ****** ** *** programming language of *** future. My ***** **.... ********AWESOME@*****.com!!!!













Files. Таск 13
Задание 13
В текстовый файл students.txt построчно записаны имя, фамилия и оценка за контрольную всех учащихся класса.
Создать функцию bad_students(filename: str) -> List[str], которая возвращает список,
 в котором хранятся фамилии всех учащихся, чья оценка меньше 4 баллов.







Files. Таск 14
Задание 14
Создайте функцию reverse_file_print(filename: str) -> None, которая выводит в обратном порядке каждую строку в указанном ей файле.

Для примера дан файл zen_of_python.txt:

входные данные:

Beautiful is better than ugly. 
Explicit is better than implicit. 
Simple is better than complex.
Complex is better than complicated.
выходные данные:

.ylgu naht retteb si lufituaeB
.ticilpmi naht retteb si ticilpxE 
.xelpmoc naht retteb si elpmiS 
.detacilpmoc naht retteb si xelpmoC 






JSON. Таск 1
JSON.
JSON, или JavaScript Object Notation - это формат для обмена данными.

Несмотря на то, что в названии присутствует слово JavaScript, JSON является абсолютно независимым от языка программирования.

Поэтому, с помощью данного формата можно обмениваться информацией с любым языком программирования, например передавать данные языка С на Java, либо с Perl на Python, с C# на JavaScript и.т.д.

JSON формат основан на двух структурах данных:

Коллекция пар ключ/значение, в Python это словарь
Упорядоченный список значений, в Python это список
Аналоги этих двух структур данных существуют почти во всех языках программирования, поэтому JSON может легко переводить данные сохраненные в этих структурах из одного языка в другой.

Допустим, у нас есть JSON файл - file.json, в которой хранится JSON строка, и нам нужно перевести данную строку в формат понятный Python.

Для этого существует два метода:

load(), десериализует файл, т.е принимает целый файл и переводит его из формата JSON в формат Python

loads(), десериализует строку, т.е принимает строку из файла и переводит ее из формата JSON в формат Python(для использования loads(), придется сперва прочитать строку методом read)

Для нашего примера подходит второй метод:

import json  
with open('file.json', 'r') as f: 
    result = json.loads(f.read()) 
Чтобы считать строку, в начале открыли файл file.json в режиме чтения r, файл обозначили переменной f.

Затем, считали содержимое файла f методом read() и передали в метод json.loads().

Результат сохранили в переменную result.

Задание 1
Вам даны два файла task1.json и task1.py.

В task1.json хранятся определенные данные, вам нужно прочитать данный файл, затем сохранить содержимое в переменной python_obj.

После, откройте файл task1.py и запишите туда содержимое переменной python_obj.






JSON. Таск 2
JSON.
Задание 2
В task2.json хранятся данные в формате JSON.

Напишите программу Python которая будет считывать данные с файла и сохранять их в переменной json_obj.

Затем, преобразуйте это обьект в объект Python и запишите результат в переменную python_obj.







JSON. Таск 3
JSON.
Процесс перевода Python объектов в формат JSON, называется сериализацией.

Для этого используют два метода:

dump(), записывает Python объекты в файл JSON, первым аргументом принимает название Python объекта, а вторым переменную обозначающую наш файл:
import json
      
obj = {'1': 'makers', '2': 'bootcamp'}      
with open("example.json", "w") as my_file:
   json.dump(obj, my_file)
Создали и открыли файл "example.json" для записи режимом w, обозначили наш файл переменной my_file.

Используя, метод dump(), мы сохранили словарь Python obj в нашем файле в перемнной my_file.

В результате, в нашей рабочей папке появится файл example.json, содержимое которого будет выглядеть данным образом:

{"1": "makers", "2": "bootcamp"} 
dumps(), сериализует Python объект в JSON строку, первым аргументом принимает название Python объекта, а вторым именованным аргументом количество отступов - indent:
import json 
     
obj = {'1': 'makers', '2': 'bootcamp'}        
json_obj = json.dumps(obj, indent=4)  
print(json_obj) 
используя метод dumps(), передали словарь Python и количество отступов 4, затем распечатали результат, в терминале получим:

{ 
 "1": "makers", 
 "2": "bootcamp" 
}
Заметьте, что в Python можно использовать одинарные кавычки, при переводе словаря в JSON формат, кавычки заменились на двойные.

Задание 3
Вам дан объект Python сохраненный в переменной python_obj и имеющий значение None.

Преобразуйте данный объект в формат JSON и сохраните в переменной json_obj.

Ввод должен быть:

python_obj = None  
#ваш остальной код 
print(json_obj)  
Вывод:

null 










JSON. Таск 4
JSON.
Задание 4
В переменной json_obj сохраните JSON объект "null", 
затем преобразуйте данный JSON объект в объект Python и сохраните в переменной python_obj.
 После распечатайте содержимое переменной python_obj.

Ввод должен быть:

json_obj = "null"  
#ваш остальной код 
print(python_obj) 
а вывод:

None






JSON. Таск 5
Задание 5
Вам дан список со словарями, сериализуйте этот список в json-строку,
результат запишите в json_users

users = [
    {
        'name': 'John',
        'last_name': 'Snow',
        'age': 26,
        'has_car': True,
    },
    {
        'name': 'Sam',
        'last_name': 'Bolt',
        'age': 4,
        'has_car': False,
    }
]







JSON. Таск 6
Задание 6
Вам дана json-строка, десериализуйте ее. Выведите названия тех продуктов, рейтинг которых больше 4
json_products = '[{"title":"iphone","price":700,"rating":4.8},{"title":"asus","price":1300,"rating":3.9},
{"title":"macbook pro","price":1500,"rating":4.9},{"title":"samsung","price":150,"rating":5.0}]'










JSON. Таск 7
Задание 7
Вам дан файл db.json. Десериализуйте данные с него.
Добавьте в каждый продукт новую пару ("description":"...").
Запишите измененные данные в файл new_db.json






JSON. Таск 8
Задание 8
Удалите из файла db.json продукт с id 3,
 запишите измененные данные в new_db.json,
  продукта с id 3 нет, все равно запишите имеющиеся данные в new_db.json






  JSON. Таск 9
Задание 9
Напишите функцию create_new(id: int, title: str, description: str,
 price: int, rating:float) -> None, которая будет запрашивать id,
 title, description, price, rating,
 собирать продукт с этими данными в виде словаря,
  и добавлять этот продукт в данные со старого db.json,
  и записывать результат в new_db.json.




  JSON. Таск 10
Задание 10
Напишите функцию get_sorted(json_filename: str) -> List[dict], 
которая будет вытаскивать все продукты из указанного json-файла и возвращать отсортированный 
список с продуктами по рейтингу (в порядке убывания)






JSON. Таск 11
Задание 11
Напишите функцию update(id: int, title: str=None, price: int=None, 
rating: float=None) -> None, 
которая будет принимать id продукта и его поля если такого продукта нет в new_db.json,
 функция вызывает ошибку ValueError
Если такой продукт есть, то у него меняются поля title, price, и rating,
 если эти поля не указаны (равны None), то их значения не меняются измененный продукт должен обновиться в new_db.json






 JSON. Таск 12
Задание 12
Напишите функцию, search(name: str) -> List[dict] 
которая принимает часть названия и выводит список из всех продуктов из db.json 
в названиях которых будет находится эта часть названия








JSON. Таск 13
Задание 13
Напишите функцию,
 filter_by_price(price: int) -> List[dict] которая принимает цену и выводит список из
  всех продуктов из db.json цена которых больше или равна заданной




  JSON. Таск 14
Задание 14
Напишите функцию bulk_create(products: List[dict]) -> None,
 которая принимает список из продуктов эти продукты должны будут добавиться в к данным из db.json, и записываться в new_db.json.
Если продукт с таким же id уже есть в new_db.json, то он не добавляется.







Заголовки. Таск 1
Заголовки
Заголовки HTML - это заголовки, которые вы хотите отображать на веб-странице.

HTML предлагает шесть заголовков разного уровня, которые показывают относительную важность секции, расположенной после заголовка. Так, тег <h1> представляет собой наиболее важный заголовок первого уровня, а тег <h6> служит для обозначения заголовка шестого уровня и является наименее значительным.

Задание
Мы создали два заголовка:

<h1>Breaking Bad</h1>
<h2>Storyline</h2>
Под вторым заголовком создайте еще два заголовка h2:

Episodes
Cast



<h1>Breaking Bad</h1>
<h2>Storyline</h2>











Пробелы. Таск 2
Пробелы, отступы, новая строка
Пробел - это любая строка текста, состоящая только из пробелов, табуляции или разрывов строки (если быть точным, последовательностей CRLF, возврата каретки или перевода строки).

Эти символы позволяют отформатировать код таким образом, чтобы его можно было легко читать вам и другим людям.

Фактически, большая часть нашего исходного кода заполнена этими пробельными символами.

Пробелы в HTML
В случае HTML пробелы в значительной степени игнорируются - пробелы между словами обрабатываются как один символ, а пробелы в начале и конце элементов и внешних элементов игнорируются. Возьмем следующий минимальный пример:

<h1>       Hello      World!     </h1> 
Браузер, вообще не заботится о них и просто показывает слова "Hello World!" как будто этих пробелов вообще не существовало: 

Новая строка
HTML-элемент <br> создает разрыв строки в тексте. Это полезно там, где разделение строк имеет большое значение.

Задание
Мы создали два разрыва строки под заголовком h1.

Под каждым заголовком h2 создайте еще по одному тегу <br>.










Комменты. Таск 3
Комменты
Комментарии HTML не отображаются в браузере, но они могут помочь документировать исходный код HTML. Синтаксис комментария выглядит так:

<!-- Комментарий --> 
Комментарии отлично подходят для отладки HTML, потому что вы можете закомментировать строки кода HTML по одной для поиска ошибок.

Note: Используйте сочетания клавиш: На устройствах Mac - CMD + / . На устройствах Windows - CTRL + /

Задание
На первой строке файла index.html создайте комментарий с текстом The IMDB series card






<h1>Breaking Bad</h1>
<br>
<br>
<h2>Storyline</h2>
<br>
<h2>Episodes</h2>
<br>
<h2>Cast</h2>
<br>















Параграф. Таск 4
Параграф
Элемент HTML <p> определяет абзац.

Абзац всегда начинается с новой строки, и браузеры автоматически добавляют пробел (поле) до и после абзаца. Пример параграфа:

<p>This is a paragraph.</p>
<p>This is another paragraph.</p> 
Задание
Мы создали параграф:

<p>
   A high school chemistry teacher diagnosed with inoperable lung cancer turns to manufacturing and selling methamphetamine in order to secure his family's future.
</p> 
Под вторым заголовком с текстом Storyline создайте параграф с текстом:

When chemistry teacher Walter White is diagnosed with Stage III cancer and given only two years to live, he decides he has nothing to lose. He lives with his teenage son, who has cerebral palsy, and his wife, in New Mexico. Determined to ensure that his family will have a secure future, Walt embarks on a career of drugs and crime.
 He proves to be remarkably proficient in this new world as he begins manufacturing and selling methamphetamine with one of his former students. 





 <!-- The IMDB series card -->
<h1>Breaking Bad</h1>
<p>
    A high school chemistry teacher diagnosed with inoperable lung cancer turns to manufacturing and selling methamphetamine in order to secure his family's future.
</p>
<br>
<br>
<h2>Storyline</h2>
<br>
<h2>Episodes</h2>
<br>
<h2>Cast</h2>
<br>











Span. Таск 5
Span
Тег <span> - это inline контейнер, используемый для разметки части текста или части документа.
 Его можно использовать для группировки элементов в целях стилизации.

Задание
Мы создали <span> на 3 строке кода:

<span>TV Series</span> 
Рядом с ним создайте еще один <span> с текстом:

2008-2013 



<!-- The IMDB series card -->
<h1>Breaking Bad</h1>
<span>TV Series</span>
<p>  A high school chemistry teacher diagnosed with inoperable lung cancer turns to manufacturing and selling methamphetamine in order to secure his family's future.
</p>
<br>
<br>
<h2>About</h2>
<br>
<h2>Storyline</h2>
<p>
  When chemistry teacher Walter White is diagnosed with Stage III cancer and given only two years to live, he decides he has nothing to lose. He lives with his teenage son, who has cerebral palsy, and his wife, in New Mexico. Determined to ensure that his family will have a secure future, Walt embarks on a career of drugs and crime. He proves to be remarkably proficient in this new world as he begins manufacturing and selling methamphetamine with one of his former students.
</p>
<br>
<h2>Episodes</h2>
<br>
<h2>Cast</h2>
<br>




Стили текста. Таск 6
Стили текста
HTML содержит несколько элементов для определения текста со специальным значением.

Элементы форматирования были разработаны для отображения специальных типов текста:

<b> - Полужирный текст
<strong> - Важный текст
<i> - Курсив
<em> - Выделенный текст
<mark> - отмеченный текст
<small> - Меньший текст
<del> - Удаленный текст
<ins> - Вставленный текст
<sub> - Подстрочный текст
<sup> - Надстрочный текст
Задание
Мы обернули текст в span в курсив и важный текст:

<span><em>TV Series</em></span>
<span><strong>2008-2013</strong></span> 
Оберните текст Walter White в Важный текст и New Mexico в курсив.





<!-- The IMDB series card -->
<h1>Breaking Bad</h1>
<span><em>TV Series</em></span> <span><strong>2008-2013</strong></span>
<p>
    A high school chemistry teacher diagnosed with inoperable lung cancer turns to manufacturing and selling methamphetamine in order to secure his family's future.
</p>
<br>
<br>
<h2>Storyline</h2>
<p>
    When chemistry teacher Walter White is diagnosed with Stage III cancer and given only two years to live, he decides he has nothing to lose. He lives with his teenage son, who has cerebral palsy, and his wife, in New Mexico. Determined to ensure that his family will have a secure future, Walt embarks on a career of drugs and crime. He proves to be remarkably proficient in this new world as he begins manufacturing and selling methamphetamine with one of his former students.
</p>
<br>
<h2>Episodes</h2>
<br>
<h2>Cast</h2>
<br>










Div. Таск 7
Div
Тег <div> определяет раздел в документе HTML.

Тег <div> используется в качестве контейнера для элементов HTML, которые затем изменяются с помощью CSS или обрабатываются с помощью JavaScript. В тег <div> можно поместить любой контент!

Note: По умолчанию браузеры всегда помещают разрыв строки до и после элемента <div>. Этим он отличается например от тега span

Задание
Мы сгруппировали два блока с названием и Storyline в div

Оберните два остальных блока также в div.











<!-- The IMDB series card -->
<div>
    <h1>Breaking Bad</h1>
    <span><em>TV Series</em></span> <span><strong>2008-2013</strong></span>
    <p> 
 A high school chemistry teacher diagnosed with inoperable lung cancer turns to manufacturing and selling methamphetamine in order to secure his family's future. 
 </p>
    <br>
    <br>
    </div>

<div>
    <h2>Storyline</h2>
    <p>
        When chemistry teacher <strong>Walter White</strong> is diagnosed with Stage III cancer and given only two years to live, he decides he has nothing to lose. He lives with his teenage son, who has cerebral palsy, and his wife, in <em>New Mexico</em>. Determined to ensure that his family will have a secure future, Walt embarks on a career of drugs and crime. He proves to be remarkably proficient in this new world as he begins manufacturing and selling methamphetamine with one of his former students.
    </p>
    <br>
</div>

<h2>Episodes</h2>
<br>

<h2>Cast</h2>
<br>









Ordered List. Таск 8
Ordered List
Тег <ol> определяет упорядоченный список. Упорядоченный список может быть числовым или алфавитным. Тег <li> используется для определения каждого элемента списка.

Задание
Мы создали упорядоченный список с эпизодами первого сезона Breaking Bad.

Создайте упорядоченный список со следующими эпизодами второго сезона Breaking Bad:

Seven Thirty-Seven
Grilled
Bit by a Dead Bee




Unordered List. Таск 9
Unordered List
Тег <ul> определяет неупорядоченный (маркированный) список.

Используйте тег <ul> вместе с тегом <li> для создания неупорядоченных списков.

Задание
Создайте неупорядоченный список с актерами сериала Breaking Bad:

Bryan Cranston
Aaron Paul
Bob Odenkirk
Giancarlo Esposito
Разместите его сразу под тегом <h2>Cast</h2>





Img. Таск 10
Img
Тег <img> используется для вставки изображения на HTML-страницу.

Изображения технически не вставляются в веб-страницу, изображения связаны с веб-страницами. Тег <img> создает пространство для хранения ссылочного изображения. Тег <img> имеет два обязательных атрибута:

src - указывает путь к изображению
alt - Задает альтернативный текст для изображения, если изображение по какой-либо причине не может быть отображено.
Note: Всегда указывайте ширину и высоту изображения. Если ширина и высота не указаны, страница может мерцать во время загрузки изображения.

Задание
Создайте 2 изображения сразу под элементом <h2>Photos</h2>.

Первое изображение должно иметь:

ссылку https://m.media-amazon.com/images/M/MV5BMjE1OTMwNTA5NV5BMl5BanBnXkFtZTgwMDkzOTA1NjM@._V1_FMjpg_UX320_.jpg,
alt school
Второе изображение должно иметь:

ссылку https://m.media-amazon.com/images/M/MV5BMjQ5MTc3NDg3MF5BMl5BanBnXkFtZTgwNTI2MTU5NTM@._V1_FMjpg_UX320_.jpg,
alt snow
Оба изображения должны быть в ширину 320px и высоту 240px










Ссылки. Таск 11
Ссылки
Тег <a> определяет гиперссылку, которая используется для перехода с одной страницы на другую.

Самым важным атрибутом элемента <a> является атрибут href, указывающий место назначения ссылки.

Для создания ссылки необходимо указать адрес документа, на который следует сделать ссылку. В качестве значения атрибута href используется адрес документа (URL), на который происходит переход.

Адрес ссылки может быть абсолютным и относительным. Абсолютные адреса работают везде и всюду независимо от имени сайта или веб-страницы, где прописана ссылка. Относительные ссылки, как следует из их названия, построены относительно текущего документа или корня сайта.

Самый простой пример ссылки:

<a href="https://www.google.com">Visit Google!</a> 
target
Атрибут target указывает, где открыть связанный документ.

Атрибут target может иметь одно из следующих значений:

_self - По умолчанию. Открывает ссылку в том же окне / вкладке, в котором он был нажат.
_blank - открывает ссылку в новом окне или на новой вкладке.
_parent - открывает ссылку в родительском фрейме.
_top - открывает ссылку во всем окне.
Используйте target = "_ blank", чтобы открыть связанный документ в новом окне или вкладке браузера:

<a href="https://www.google.com" target="_blank">Visit Google!</a> 
Задание
Прикрепите ссылку на профиль ко всем 4 актерам:

Bryan Cranston - ссылка https://www.imdb.com/name/nm0186505/,
Aaron Paul - ссылка https://www.imdb.com/name/nm0666739/,
Bob Odenkirk - ссылка https://www.imdb.com/name/nm0644022/,
Giancarlo Esposito - ссылка https://www.imdb.com/name/nm0002064/.
Для примера возьмите ссылку, которую мы прикрепили к заголовку Breaking Bad














Аттрибут ID. Таск 12
Аттрибут ID
Атрибут id используется для указания уникального идентификатора HTML-элемента.

В документе HTML не может быть более одного элемента с одинаковым идентификатором.

Атрибут id определяет уникальный идентификатор для элемента HTML. Значение атрибута id должно быть уникальным в документе HTML.

Самый простой пример написания id:

<h1 id="myUniqueID">Header</h1>

Note: Имя идентификатора чувствительно к регистру!

Note: Имя идентификатора должно содержать хотя бы один символ, не может начинаться с числа и не должно содержать пробелов (пробелов, табуляции и тд).

Закладки HTML
ID могут использоваться для того, чтобы позволить читателям переходить к определенным частям веб-страницы.

Закладки могут быть полезны, если ваша страница очень длинная.

Чтобы использовать закладку, вы должны сначала создать ее, а затем добавить на нее ссылку.

Затем, когда ссылка будет нажата, страница будет прокручена до места с закладкой.

Задание
Задайте id следующим блокам:

Блоку с эпизодами и сезонами - episodes,
Блоку с актерами - cast,
Блоку с фото - photos,
После закрывающего тега div на 14 строке создайте еще 4 span с ссылками на соответствующие блоки.










Универсальный селектор. Таск 1
Universal Selector
Универсальный селектор * выбирает все элементы HTML на странице. Например правило CSS ниже повлияет на каждый элемент HTML на странице:

* {
  text-align: center;
  color: blue;
} 
Задание
Необходимо убрать нижнее подчеркивание со всех элементов a, используя универсальный селектор.

Note: пишите все правила в файле style.css.




<div>
    <img
        alt="poster"
        src="https://m.media-amazon.com/images/M/MV5BNTEwMDhmNmUtNGJmNi00NGUwLTkxOWQtNzI1NDUwZTFkMThkXkEyXkFqcGdeQXVyNjg0Nzk2Nzc@._V1_FMjpg_UX480_.jpg"
        width="400"
        height="226" 
    />
    <a href="https://www.imdb.com/title/tt0903747">
        <h1>
            Breaking Bad
        </h1>
    </a>
    <span>
        <em>TV Series</em>
    </span>
    <span>
        <strong>2008-2013</strong>
    </span>
    <ul>
        <li>Thriller</li>
        <li>Drama</li>
    </ul>
    <p>
        A high school chemistry teacher diagnosed with inoperable lung cancer turns to manufacturing and selling methamphetamine in order to secure his family's future.
    </p>
    <br>
    <br>
</div>

<span>
    <a href="#storyline">Storyline</a>
</span>
<span>
    <a href="#episodes">Episodes</a>
</span>
<span>
    <a href="#cast">Cast</a>
</span>
<span>
    <a href="#photos">Photos</a>
</span>

<div id="storyline">
    <h2>Storyline</h2>
    <p>
        When chemistry teacher <strong>Walter White</strong> is diagnosed with Stage III cancer and given only two years to live, he decides he has nothing to lose. He lives with his teenage son, who has cerebral palsy, and his wife, in <em>New Mexico</em>. Determined to ensure that his family will have a secure future, Walt embarks on a career of drugs and crime. He proves to be remarkably proficient in this new world as he begins manufacturing and selling methamphetamine with one of his former students.
    </p>
    <br>
</div>

<div id="episodes">
    <h2>Episodes</h2>
    <h3>Season 1</h3>
    <ol>
        <li>Pilot</li>
        <li>Cat's in the Bag...</li>
        <li>..And the Bag's in the River</li>
    </ol>
    <h3>Season 2</h3>
    <ol>
        <li>Seven Thirty-Seven</li>
        <li>Grilled</li>
        <li>Bit by a Dead Bee</li>
    </ol>
    <br>
</div>

<div id="cast">
    <h2>Cast</h2>
    <ul>
        <li><a href="https://www.imdb.com/name/nm0186505/">Bryan Cranston</a></li>
        <li><a href="https://www.imdb.com/name/nm0666739/">Aaron Paul</a></li>
        <li><a href="https://www.imdb.com/name/nm0644022/">Bob Odenkirk</a></li>
        <li><a href="https://www.imdb.com/name/nm0002064/">Giancarlo Esposito</a></li>
    </ul>
    <br>
</div>

<div id="photos">
    <h2>Photos</h2>
    <img alt="school" width="320" height="240" src="https://m.media-amazon.com/images/M/MV5BMjE1OTMwNTA5NV5BMl5BanBnXkFtZTgwMDkzOTA1NjM@._V1_FMjpg_UX320_.jpg" /> 
    <img alt="snow" width="320" height="240" src="https://m.media-amazon.com/images/M/MV5BMjQ5MTc3NDg3MF5BMl5BanBnXkFtZTgwNTI2MTU5NTM@._V1_FMjpg_UX320_.jpg" /> 
</div>



Tag Селектор. Таск 2
Tag Селектор
Tag селектор выбирает все элементы HTML с этим тегом на странице.

Например правило CSS ниже повлияет на каждый элемент <p> на странице:

p {
  color: blue;
}
Задание
Необходимо задать цвет тегу h1 и h2, используя tag селектор.

Для h1 задайте цвет red.

Для h2 задайте цвет green.



Class Селектор. Таск 3
Class Селектор
Задание
Необходимо задать class season2 нумерованному списку с эпизодами второго сезона, используя class селектор.
в CSS задайте классу season2 цвет violet.




Multiclass Селектор. Таск 4
Multiclass Селектор
Задание
Необходимо задать class bold нумерованному списку с эпизодами первого сезона, используя class селектор.
в CSS задайте классу bold стиль жирный.
Необходимо задать class italic нумерованному списку с эпизодами второго сезона, используя class селектор.
в CSS задайте классу italic стиль курсив.



ID Селектор. Таск 5
Id Селектор
Ранее мы уже изучали селектор id и знаем, что в отличие от класса, он может применяться только к одному HTML элементу.

Задание
Необходимо задать id ссылкам с именами актеров, используя id селектор.
Ссылке с Aaron Paul задайте id jesse и в CSS задайте цвет darkblue.
Ссылке с Bob Odenkirk задайте id saul и в CSS задайте цвет darkgreen.
Ссылке с Giancarlo Esposito задайте id gus и в CSS задайте цвет darkred.




Attribute Селектор. Таск 6
Attribute Селектор
Можно стилизовать элементы HTML, которые имеют определенные атрибуты или значения атрибутов.

Селектор аттрибута
Селектор [attribute] используется для выбора элементов с указанным атрибутом.

В следующем примере выбираются все элементы <a> с целевым атрибутом:

a[target] {
  background-color: yellow;
} 
Селектор значения аттрибута
Селектор [attribute = "value"] используется для выбора элементов с указанным атрибутом и значением.

В следующем примере выбираются все элементы <a> с атрибутом target = "_ blank":

a[target="_blank"] {
  background-color: yellow;
} 
Задание
Необходимо поменять все буквы в именах актеров на заглавные, используя селектор аттрибута href.
При этом ссылка Breaking Bad не должна поменяться.









Parsing. Таск 1
Статус код запроса
Библиотека requests помогает нам работать с HTTP запросами. Так как мы работаем с веб-страницами размещенными в интернете, все взаимодействия с веб-страницами происходят через запросы HTTP - специального протокола.

У requests есть метод status_code, с помощью которого можно получить статус ответа на наш запрос, к примеру: 200 - ОК, или 404 - страница не найдена.

Задание 1
Нужно получить статус запроса доступа к странице:

https://stackoverflow.com/questions

В начале, получите статус запроса и присвойте результат запроса к переменной source.

Затем выведите эту переменную в консоль.

Примерный вывод в консоли:

200 
функцию создавать не нужно, весь код прописывайте сразу в терминале








Parsing. Таск 2
BeautifulSoup
BeautifulSoup может извлекать информацию из HTML, а также имеет ряд методов для работы с HTML тегами. Используя requests получим доступ к веб-странице, затем с помощью BeautifulSoup и библиотеки-парсера lxml сохраним веб-страницу в переменной my_page:

source = requests.get('http://www.адрес_веб-страницы.com/').text 
my_page = BeautifulSoup(source, 'lxml')
Если веб-страница имеет простую структуру, часто информацию из тегов можно легко извлечь, обращаясь к ним как к аттрибутам объекта BeautifulSoup и используя свойство text для поиска текста.
К примеру, надо вывести текст тега <div>:

print(my_page.div.text) 
Задание 2
Спарсите тэги h1, p и ссылку с тэга a из веб-страницы:

http://www.example.com/

и выведите результат в консоль в таком виде:

h1:  Example Domain

p:  This domain is for use in illustrative examples in documents. You may use this domain in literature without prior coordination or asking for permission.

a:  https://www.iana.org/domains/example  







Parsing. Таск 3
Метод find_all
find_all просматривает все вложенные элементы указанного тега, а также может производить поиск по указанному классу тега.

find_all возвращает все совпадения в виде списка, например:

my_page.find_all('p', 'title')  
в my_page хранится страница в виде объекта BeautifulSoup, с помощью find_all указываем найти все теги <p>, с классом title, получим список:

[<p class="title">Хоббит, или Туда и Обратно</p> , 
<p class="title">Сильмариллион</p>, 
<p class="title">Неоконченные предания Нуменора и Средиземья</p>] 
Теперь, с данным списком можно работать как с обычным объектом Python - перебирать циклами, использовать в функциях и.т.п

Задание 3
Выведите с главной страницы википедии:

https://www.wikipedia.org/

сколько всего статей есть немецком языке.

Вывод в консоль должен быть таким:

Deutsch

2 590 000+ Artikel 






Parsing. Таск 4
try...except и if...else
В веб-скрейпинге, часто приходится извлекать большое количество данных, где некоторые элементы могут отсутствовать на странице. BeautifulSoup позволяет нам манипулировать данными как с объектами Python.

Поэтому, мы можем использовать try...except или if ... else для выявления дефектов в HTML разметке.

К примеру, мы парсим видео ссылки с веб-сайта и чтобы наш код не сломался, если ссылка отсутствует, обернем наш код в try...except:

for post in my_page.find_all('post'): 
     try: 
         link = post.find('a', 'youtube')['src'] 
     except Exception as e: 
         link = None 
Проходимся циклом по списку постов, которые мы получили методом find_all. Затем пробуем вывести ссылку на видео для каждого post с помощью метода find, который возвращает первое совпадение. Если у поста нет видео, наш цикл не сломается, а просто возвратит None.

Задание 4
Напишите программу которая проверяет имеет ли страница заголовок(тэг h1) или нет.

Для этого напишите функцию getTitle() которая будет принимать url страницы и возвращать заголовок если он есть, если же его нет то будет возвращать "Title could not be found"

 print(getTitle('http://www.example.com/'))
Output:

 <h1>Example Domain</h1>











 Parsing. Таск 5
Задание 5
Напишите код который сохраняет все названия категорий со страницы:

https://enter.kg/

в список category_list.

После, напишите функцию которая имеет два параметра - список категорий - categories и ключевое слово - keyword.

Функция должна производить поиск по ключевому слову в списке заголовков category_list и возвращать список заголовков которые содержат данное слово (независимо от регистра).

К примеру:

print(find_category(category_list, 'Ноутбуки')) 
Вывод будет:

['Ноутбуки, Ультрабуки, Гот. решения (1281)', 'Ноутбуки (1235)', 'Ноутбуки, Ультрабуки, Гот. решения(1281)', 'Ноутбуки и ультрабуки'] 











Parsing. Таск 6
Задание 6
Напишите программу которая будет парсить топ 250 фильмов с сайта IMBD:

https://www.imdb.com/chart/top

Затем напишите функцию get_link, которая будет принимать в аргументы список фильмов - title_list и строку - name. Функция должна производить поиск в списке по строке и возвращать ссылку на фильм. Вы должны вернуть только первое совпадение в списке.

Например:

get_link(title_list, 'shawshank') 
Вернет вам:

https://www.imdb.com/title/tt0111161/ 




Введение в ООП. Таск 1
Введение в ООП.
В Python уже существуют готовые для работы объекты - строки, числа, списки и.т.п, у этих объектов также есть свои методы и свойства. Таким же образом, мы можем создавать свои объекты, давать им методы, свойства и определять их поведение.

К примеру, создадим шаблон для объектов под названием MyObject:

class MyObject: 
мы хотим чтобы у каждого объекта созданного от класса MyObject было название - name, нам нужно связать переменную name с нашим объектом, для этого существует встроенный метод __init__.

Помимо __init__, внутри классов есть метод __new__. Работу данных методов можно представить так, допустим у нас есть завод по выпуску автомобилей, __new__ срабатывает тогда, когда мы утвердили идею выпуска нового авто, а __init__ срабатывает позже, когда запускается сам процесс сборки новой модели авто. На этом этапе мы можем изменить и добавить новые характеристики авто(вид двигателя, цвет кузова и.т.д).

Eсли мы хотим дать всем объектам класса MyObject свойство name, можем переопределить метод __init__:

class MyObject: 
def __init__(self, name): 
  self.name = name 
по умолчанию, метод __init__ принимает один аргумент self, в self хранится ссылка на сам объект, после self можем добавлять свои свойства. Чтобы связать эти свойства с объектом, указываем через ссылку на объект в self.name свойство name.

Создать объект можно прописав любую переменную и присвоив ее к классу MyObject(), в скобках нужно прописать название объекта, а в self попадет сама ссылка на нашу переменную:

object1 = MyObject('первый объект') 
Для объектов созданных от какого-либо класса также часто используется термин-синоним экземпляр класса

Задание 1
Создайте класс для песен Song. Каждая песня имеет название - title, автора - author и год выпуска - year.

Добавьте три метода:

show_author

show_title

show_year

выводящие утверждения о каждом атрибуте экземпляра класса Song.

Создайте экземпляр song класса Song с вашей любимой песней и примените все методы.

Например:

print(song.show_title())
print(song.show_author())
print(song.show_year())
Вывод:

Название этой песни Happy
Автор этой песни Pharrell Williams
Эта песня вышла в 2013 году








Введение в ООП. Таск 2
Введение в ООП.
Мы уже знаем что через метод __init__ можем задать свойства, или как еще их называют аттрибуты экземпляров класса. Каждый аттрибут заданный через __init__ привязан отдельно к каждому из объектов класса. Внутри класса, можно также создать общие аттрибуты для всех объектов класса, которые называются переменными класса.

К примеру, у нас есть класс SolarSystem - солнечная система:

class SolarSystem: 
  def __init__(self, planet): 
      self.planet = planet 
от этого класса можно создать объекты-планеты.

Для всех объектов солнечной системы есть одна единственная звезда - солнце, поэтому мы можем записать star как переменную для всего класса со значением Sun:

class SolarSystem: 
    star = 'Sun' 
    def __init__(self, planet): 
        self.planet = planet  
переменная star будет существовать для любого объекта созданного от данного класса, проверить можно создав разные экземпляры класса и выведя для каждого из них переменную star через точку:

first = SolarSystem('Mercury') 
print(first.star) 
second = SolarSystem('Venus') 
print(second.star) 
Получим в терминале вывод:

Sun 
Sun 
Задание 2
Создайте класс Circle, с переменными класса задающие по умолчанию цвет круга - синий, в переменной color, и число Пи(3.14) - в переменной pi.

Экземпляры класса Circle в свою очередь должны иметь обязательное свойство - радиус, в переменной radius.

К примеру, создадим объект с радиусом 2:

circle = Circle(2) 
Также, класс должен иметь метод расчета площади круга - get_area():

circle.get_area() 
Возвращает:

12.56 
формула расчета площади: число Пи умножить на радиус в квадрате

cоздайте экземпляр класса,
переопределите цвет экземпляра и
примените метод get_area().
Распечатывать результат не нужно, методы должны возвращать результат ключевым словом return.






class Circle:
    ... 










Введение в ООП. Таск 3
Введение в ООП.
Помимо обычных аттрибутов объектов класса, можно также создавать свойства привязанные к объектам с уже имеющимися значением.

То есть, нам не нужно будет указывать новые значения свойств в __init__ при создании каждого объекта, эти свойства уже будут иметь значения по умолчанию и будут привязаны к каждому из объектов класса.

Допустим у нас есть класс:

class Auto: 
   def __init__(self): 
у каждого автомобиля есть свойство пробег - mileage, мы будем полагать что все наши машины масловые, а значит каждый объект-авто созданный от нашего класса будет уже иметь пробег равный 0:

class Auto: 
   def __init__(self): 
       self.mileage = 0 
так как, это значение изначально равно 0, мы не будем прописывать его каждый раз при создании объекта-автомобиля, а сразу привяжем к объекту через self - self.mileage = 0.

Теперь добавим метод drive, который будет увеличивать наш пробег mileage:

class Auto: 
   def __init__(self): 
       self.mileage = 0 
    
   def drive(self, km): 
       self.mileage += km 
       return self.mileage 
для того, чтобы мы могли изменить аттрибут объекта, нам нужно обращаться к нему через объект, т.е через self, поэтому передаем self в параметры метода drive, а вторым параметром будет km - километры.

Внутри метода, добавляем к self.mileage каждый переданный километр и перезаписываем новое значение в переменную mileage. В конце, возвращаем пробег с помощью ключевого слова return.

Создадим объект от нашего класса, и применим метод drive:

auto = Auto() 
print(auto.mileage(500)) 
получаем в терминале:

500 
Задание 3
Создайте класс BankAccount, у объектов данного класса есть аттрибут balance со значением по умолчанию 0: balance = 0.

Определите метод withdraw с параметром amount, который будет отнимать сумму от баланса и распечатывать текущий баланс.

Добавьте еще один метод deposit, который также имеет параметр amount и соответсвенно добавляет сумму к балансу и распечатывает баланс.

Например:

account.deposit(1000) 
account.withdraw(500) 
Получим такой вывод:

Ваш баланс: 1000 сом 
Ваш баланс: 500 сом 
в начале, увеличили переменную balance на 1000, затем уменьшили на 500, и получили в итоге 500.









Введение в ООП. Таск 4
Введение в ООП.
Задание 4
Создайте класс Taxi, объекты которого имеют такие атрибуты как название компании - name, стоимость посадки - cost, стоимость за каждый пройденный километр - cost_km.

Добавьте к классу метод get_total_cost, принимающий параметр km - сколько километров составила поездка и возвращающий стоимость поездки.

Создайте три экземпляра класса Taxi для трех разных компаний Namba, Yandex и Jorgo и расчитайте стоимость поездки на каждой из них.

Например:

print(taxi1.get_total_cost(10)) 
print(taxi2.get_total_cost(6)) 
print(taxi3.get_total_cost(14))  
Вывод:

Такси Namba, стоимость поездки: 179 сом 
Такси Yandex, стоимость поездки: 127 сом 
Такси Jorgo, стоимость поездки: 238 сом  










Введение в ООП. Таск 5
Введение в ООП.
Задание 5
Создайте класс телефонной книги Phone. У контактов должны быть такие аттрибуты:

name - имена
last_name - фамилии
phone - телефонные номера
Добавьте метод get_info, который выводит информацию о контакте в следующем виде:

contact.get_info()
Вывод в терминал:

Контакт: John Snow, телефон: +996707707707
Затем, создайте объект от класса Phone в переменной contact и примените метод get_info.







Введение в ООП. Таск 6
Введение в ООП.
Задание 6
Напишите класс Salary для расчета налогов на заработную плату. У класса должна быть обязательная переменная класса - percent = 8, обозначающий процент налога на ежемесячную зарплату - 8%.

Объекты класса должны иметь, в качестве атрибутов сумму зарплаты salary и стаж работы в месяцах - experience.

Также у класса должен быть метод count_percent, расчитывающий сумму налога заплаченного за весь стаж работы.

Создайте экземпляр класса obj и посчитайте сумму вашего налога.

К примеру, если у вашего объекта salary имеет значение 10000, а experience равен 10, то:

print(obj.count_percent()) 
Выдаст вам такой результат в терминале:

8000.0 
Каждый месяц с зарплаты в 10000 сомов снимается 8% на налоги, т.е 800 сом, за 10 месяцев трудового стажа эта сумма будет 8000.0 сом










Введение в ООП. Таск 7
Введение в ООП.
Задание 7
Вам дан такой код:

winner1 = Nobel("Литература", 1971, "Пабло Неруда") 
print(winner1.category, winner1.year, winner1.winner) 
print(winner1.get_year())

  
winner2 = Nobel("Литература", 1994, "Кэндзабуро Оэ") 
print(winner2.category, winner2.year, winner2.winner) 
print(winner2.get_year())
который выводит в терминал такие значения:

Литература 1971 Пабло Неруда
выиграл 51 лет назад 
Литература 1994 Кэндзабуро Оэ 
выиграл 28 лет назад
Напишите класс Nobel, который будет принимать аттрибуты category, yearи winner. Создайте метод get_year(), который будет выводить сколько лет назад была получена премия в виде 'выиграл {кол-во лет} лет назад'.

Дату сколько лет назад была получена премия в методе get_year() не вписывать вручную, а высчитывать используя datetime













Введение в ООП. Таск 8
Введение в ООП.
В Python есть два специальных метода __str__ и __repr__. Эти методы чаще всего работают без нашего вмешательства, к примеру метод __str__ мы никогда напрямую не вызывали, но он срабатывал каждый раз как мы использовали print().

Метод __str__ возвращает понятное человеку, строковое представление объекта. __str__ можно легко переопределять внутри класса и изменять вид в котором мы распечатываем объект.

К примеру, у нас есть класс и созданный от него объект, который мы попробуем распечатать:

class MyClass: 
     def __init__(self, name): 
         self.name = name

obj = MyClass('первый объект')

print(obj)
в результате получим данную запись в терминале:

<__main__.MyClass object at 0x7f53ba5948b0> 
однако, если мы перепишем метод __str__, который также как и __init__ принимает в аргументы self, можем поменять поведение объекта при использовании print().

Допустим, мы хотим чтобы в терминале выводился аттрибут объекта name:

class MyClass: 
     def __init__(self, name): 
         self.name = name 

     def __str__(self): 
         return self.name

obj = MyClass('первый объект') 
print(obj) 
здесь мы получили доступ к аттрибуту name через ссылку на сам объект в self - self.name, и возвратили в качестве конечного результата работы метода __str__ с помощью return.

Получаем в терминале:

первый объект 
В свою очередь, метод __repr__ возвращает объект в том виде в котором мы можем его распечатать, при этом он не заботится о том чтобы запись была понятна обычным людям.

Задача __str__ состоит в том чтобы быть читаемым, задача же __repr__ состоит в том чтобы быть конкретным.

Задание 8
Создайте класс Password, экземеплярами класса являются пароли в виде строк. У класса должен быть метод validate для валидации пароля:

В начале, проверьте, что пароль состоит из минимум 8 символов, но меньше 15, если условие не соблюдено, должны выйти ошибка с текстом:
Password should be longer than 8, and less than 15
Вторая проверка должна проверять что пароль содержит цифры, и в случае отсутствия цифр, выводить ошибку с текстом:
Password should contain numbers too
Третья проверка, проверяет содержит ли пароль буквы и в случае не совпадения, выводит ошибку с текстом:
Password should contain letters as well
В конце проверьте, содержит ли пароль хотя бы один из символов: '@', '#', '&', '$', '%', '!', '~', '*', если условие не выполнено выводите ошибку с текстом:
Your password should have some symbols
если одно из условий не выполнено, выводите соответствующее исключение, если же все условия выполнены метод validate должен возвращать строку:

Ваш пароль сохранен.
Также переопределите метод __str__, чтобы при попытке распечатать сам пароль, вам выдавалась строка из звездочек количество которых равно длине пароля.

К примеру, если пароль joe@123456, при попытке распечатать пароль, в терминал должно выводиться: **********

пишите код для проверки пароля в указанном порядке











Введение в ООП. Таск 9
Введение в ООП.
Задание 9
Создайте класс Math, у экземпляра которого должно быть свойство number. У классa Math должно быть 3 метода:

get_factorial - возвращает факториал числа(перемножить все составные числа до самого числа)

get_sum - возвращает сумму цифр числа

get_mul_table - возвращает таблицу умножения для числа до 10 в формате:

5x1=5
5x2=10
5x3=15
5x4=20
5x5=25
5x6=30
5x7=35
5x8=40
5x9=45
5x10=50
Создайте экземпляр класса и примените к нему все методы.

Например, если экземпляром класса Math является число 11,

вызов get_factorial возвратит такой результат:

39916800 
т.к 1 x 2 x 3 x 4 x 5 x 6 x 7 x 8 x 9 x 10 x 11 = 39916800

метод get_sum, возвратит:

2 
т.к число 11 состоит из двух цифр 1 и 1, сумма 1 + 1 = 2

метод get_mul_table возвратит:

11 x 1 = 11 
11 x 2 = 22 
11 x 3 = 33 
11 x 4 = 44 
11 x 5 = 55 
11 x 6 = 66 
11 x 7 = 77 
11 x 8 = 88 
11 x 9 = 99 
11 x 10 = 110 
результат методов возвращайте ключевым словом return, print() использовать не надо.













Введение в ООП. Таск 10
Введение в ООП.
Задание 10
Создайте класс ToDo, экземплярами данного класса являются строки-задачи(сходить в кино, сделать домашку, выгулять собаку и.т.д).

У класса должна быть переменная класса instances значением которой является пустой словарь.

Создайте внутри класса метод give_priority, который имеет параметр priority, 
куда принимает число - приоритет вашей задачи (1, 2, 3) и записывает вашу задачу в словарь instances с ключом в виде числа - priority, а значением в виде вашей задачи.

Например:

{3: 'сходить в кино'}
приоритет сходить в кино у вас не самый высокий.

{1: 'сделать домашку'}
в этом случае это у вас самая важная задача, с приоритетом 1.

При каждом вызове метода give_priority - словарь в instances обновляется. 
Если вы создали три объекта от класса ToDo и к каждому объекту вызвали метод give_priority и дали приоритет, 
то ваш словарь в instances в конце будет выглядеть примерно так:

{3: 'сходить в кино', 1: 'сделать домашку', 2: 'выгулять собаку'} 
У класса должен быть метод list_of_tasks, который возвращает вам список отсортированных задач по приоритету:

[(1, 'сделать домашку'), (2, 'выгулять собаку'), (3, 'сходить в кино')]











Наследование. Таск 1
Принципы ООП. Наследование.
С помощью принципа ООП наследования, можно вынести общие "черты", характеристики нескольких классов в один родительский класс.

Наследование позволяет нам не повторяться и делает наш код более организованным. Давайте рассмотрим простой пример:

class Parent: 
     def __init__(self): 
         pass 

     def method(self): 
         return 'Метод класса Parent' 

class Child(Parent): 
     pass 
для того чтобы наследовать класс Child от класса Parent, после названия Child,
 в скобках прописываем название класса от которого наследуем - class Child(Parent).

Теперь все методы и свойства которые есть у Parent, будут доступны в Child:

obj = Child() 
print(obj.method()) 
распечатает в терминале:

Метод класса Parent 
несмотря на то, что мы создали объект obj от класса Child, внутри которого данного метода нет.

Дочерние классы могут наследовать методы от родительских и переопределять(изменять)
 их внутри своего класса и при этом это никак не повлияет и не изменит сам родительский класс.

Задание 1
Создайте класс Class1 с 2 методами - first и second.

Создайте второй класс Class2, который наследуется от Class1, и определите в новом классе Class2 ещё 2 метода - third и fourth.

Создайте экземпляр obj от класса Class2 и вызовите у него все четыре метода.

внутри методов прописывать и возвращать ничего не нужно, можно просто оставить
 ключевое слово pass. pass говорит Python что функция пока ничего не выполняет, но в будущем возможно вы вернетесь и допишите туда код.










 Наследование. Таск 2
Принципы ООП. Наследование.
Одним из главных преимуществ наследования является возможность расширения родительских методов.

Наследуя от родительского класса, можно дополнить, либо полностью изменить методы родительского класса в дочернем.

У нас есть родительский и дочерние классы:

class Transport: 
     def move(self): 
         print("движется:") 
 
class Boat(Transport): 
     pass 

class Car(Transport): 
     pass 
у родительского класса Transport есть метод move, т.е любой транспорт может двигаться.

От Trasnport наследуем классы Boat - лодка, и Car - машина.

Для Boat и Car метод move уже доступен, так как они унаследовали его сразу от родителя,
 но допустим мы хотим расширить метод move и добавить дополнительный функционал.

Для этого воспользуемся функцией super():

class Transport: 
     def move(self): 
         print("движется:") 

class Boat(Transport): 
     def move(self): 
         super().move() 
         print("плывет") 

class Car(Transport): 
     def move(self): 
         super().move()  
         print("едет") 
к каждому из дочерних классов прописываем метод move,
 внутри move в начале прописываем функцию super(), которая указывает на родительский класс(говорит Python: "ищи у родителя")

через точку указываем что именно мы хотим перенять, в нашем случае метод move() - super().move().

После того как мы переняли сам метод, можем расширить его, дописав дополнительный код, 
в Boat мы добавили - print("плывет"), а в Car - print("едет").

Создадим объект от Boat и вызовем метод move:

boat = Boat() 
boat.move() 
В терминале получим:

движется: 
плывет 
Проделаем тоже самое с Car:

car = Car() 
car.move() 
Вывод будет:

движется: 
едет 
Задание 2
Создайте класс A и определите в нём метод method1, который будет печатать строку

Основной функционал
Затем создайте второй класс B, который наследуется от класса A.

Внутри класса B переопределите method1 таким образом, чтобы он помимо строки "Основной функционал", также печатал строку

Дополнительный функционал
Объявите экземпляр класса B в переменной obj и вызовите метод method1. Результат в терминале должен быть:

Основной функционал 
Дополнительный функционал 











Наследование. Таск 3
Принципы ООП. Наследование.
Все в языке Python является объектом, то есть имеет свои аттрибуты и методы, такие же как мы прописывали для созданных нами классов.

Каждый тип данных относится к своему классу, созданный нами словарь это объект класса dictionary, число в нашем коде - объект от класса integer, строка 'hello' которую мы можем распечатать является экземпляром класса string.

Это значит что мы можем наследовать наши собственные классы от этих встроенных классов.

Создадим свой класс Number, который наследуется от встроенного int:

class Number(int): 
     def __init__(self, value): 
         self.value = value
    
     def count_digits(self): 
         digits = len(str(self.value)) 
         return digits 
у чисел в Python нет метода высчитывающего из скольких цифр состоит число, напишем свой метод count_digits, который переводит каждое число в тип данных string и возвращает длину строки.

Создадим экземпляр класса Number в переменной num, со значением в value - 123 и применим к нему метод count_digits:

num = Number(123) 
print(num.count_digits()) 
Получим вывод в терминале:

3 
т.к цифр в числе 123 - три.

Если мы попробуем создать объект от Number не с числом, а со строкой:

num = Number('hello') 
наследование от класса int, не допустит объекты с не числовым значением и выдаст нам исключение:

ValueError: invalid literal for int() with base 10: 'hello' 
таким образом можем удостовериться что наследование от int в нашем классе работает.

Задание 3
Создайте класс MyString, который будет наследоваться от str.

Определите 2 своих метода:

append, который будет принимать строку и добавлять её в конец исходной

pop, который удаляет из строки последний элемент и возвращает его.

Затем, создайте экземпляр example от класса MyString со значением String. Добавьте к example строку 'hello' методом append, затем примените метод pop.

Пример:

example = MyString('String') 
example.append('hello') 
print(example) 
Вывод в терминал будет:

Stringhello 
Применим метод pop() к объекту example:

print(example.pop()) 
print(example) 
cам метод возвратит нам удаленную строку, в терминале получим:

o 
Stringhell 













Наследование. Таск 4
Принципы ООП. Наследование.
Наследуя от встроенных классов, мы также можем переопределять родительские методы,
 то есть встроенные методы типов данных.

Создадим свой класс MyList,
 наследуя от встроенного класса list и переопределим встроенный метод списков append 
 таким образом чтобы при добавлении нового элемента нам печаталась строка "добавил!":

class MyList(list): 
     def append(self, object): 
         print('добавил!') 
         return super().append(object) 
метод append принимает ссылку на объект в self и второй параметр - объект который мы хотим добавить в список(у нас в переменную object).

Добавляем print('добавил!'), затем возвращаем родительский метод класса list через функцию super(),
 говорим какой именно метод переопределяем - встроенный append и передаем объект который нужно добавить - super().append(object).

Создадим экземпляр класса MyList в перемнной lst, применяя метод append добавим новый элемент в список:

lst = MyList([1, 2, 3]) 
print(lst.append(4)) 
print(lst) 
Получим в терминале:

добавил! 
[1, 2, 3, 4] 
Благодаря тому, что мы корректно унаследовали родительский метод через функцию super(), встроенный метод append не сломался и работает правильно.

Задание 4
Создайте класс MyDict который будет наследоваться от встроенного класса dict. Переопределите метод get() таким образом,
 чтобы при попытке получения несуществующего ключа, по умолчанию он возвращал, вместо None, строку:

Are you kidding?
Создайте экземпляр класса в переменной 'obj_dict' и попробуйте получить несуществующий ключ методом get().

Например:

obj_dict = MyDict({'some_title': 2}) 
print(obj_dict.get('some')) 
Ключа 'some' в нашем словаре нет, есть только 'some_title', в терминале получим:

Are you kidding? 
Метод get имеет такой синтаксис: словарь.get(ключ, значение),
 в значение передается то что вы хотите возвратить если такого ключа не существует. По умолчанию, если второе значение не передано,
 метод возвращает None. Для переопределения метода унаследуйте метод от родителя и передайте в метод свое значение.










 Наследование. Таск 5
Принципы ООП. Наследование.
Помимо обычных методов, в Python можно также наследовать __init__ родительского класса. К примеру, у нас есть класс Person(человек) объекты которого имеют атрибут name:

class Person: 
 def __init__(self, name): 
     self.name = name  
теперь, создадим класс Employee(работник) который наследуется от класса Person, у объектов Employee также должны быть имена - name, но мы хотим добавить еще один атрибут - job(работа).

Для этого, переопределяем функцию __init__, в параметры записываем атрибуты которые нам нужны - self, name и job.

Внутри функции, унаследуем родительский метод __init__ через super(), и в скобках укажем какой атрибут нам нужен из родительского класса - name.

Затем, привяжем новый атрибут job через ссылку на объект self:

class Employee(Person): 
  def __init__(self, name, job): 
      super().__init__(name) 
      self.job = job 
теперь объект созданный от класса Employee будет иметь атрибуты name и job:

obj = Employee('Steve', 'programmer') 
Задание 5
Создайте класс Person который будет описывать человека, а точнее его имя - name и возраст - age. Добавьте к классу метод display(), который будет выводить данные об этом человеке.

Создайте второй класс Student, который будет наследоваться от класса Person.

Объекты от класса Student должны иметь все атрибуты, которые были определены в родительском классе и еще один дополнительный атрибут - faculty, который будет описывать факультет, где учится студент.

Создайте метод display_student(), который будет выводить данные об этом студенте.

Создайте от класса Student объект в перемнной obj_student, и выведите данные о нём, как о человеке, затем как о студенте.

Например, применим методы к объекту obj_student:

obj_student.display() 
obj_student.display_student() 
допустим, у нашего объекта в атрибуте name хранится значение Rick, в age - 21, а в faculty значение science, вывод в терминал должен быть:

name:Rick, age:21 
name:Rick, age:21, faculty:science 








Наследование. Таск 6
Принципы ООП. Наследование.
Каждый раз как мы создаем метод внутри класса, мы обязательно передаем в параметры self - ссылку на сам объект созданный от класса.

Зачем же нам нужен self в методах?

Создадим класс A, у которого есть один метод, который просто распечатывает строку 'hey!'. Создадим экземпляр класса в переменной x и применим к нему метод:

class A: 
  def method(self): 
      print('hey!') 
 
x = A()  
x.method() 
получим вывод в терминале:

hey! 
тут, нигде явно не видна работа параметра self, self также не используется внутри функции.

Попробуем удалить self из метода и заново применить метод к объекту x:

class A: 
 def method(): 
     print('hey!') 

x = A() 
x.method() 
получим в терминале исключение:

TypeError: method() takes 0 positional arguments but 1 was given  
#метод не принимает никаких позиционных аргументов, но мы передали 1 
Сама привязка метода к объекту - x.method(), то есть в том месте где мы указываем наш объект ставим точку и вызываем метод, и является тем самым self который мы указываем при создании метода.

Мы убрали self из метода и попытались привязать объект x к методу method, в итоге Python не понял куда именно поместить ссылку на объект, так как у метода нет никаких параметров, скобки пустые и выдал исключение.

В self всегда хранится ссылка на наш объект, поэтому чтобы привязать метод или атрибут к объекту или манипулировать объектом с помощью циклов, функций, встроенных методов мы должны обращаться к нему через self.

Задание 6
Создайте класс ContactList, который должен наследоваться от встроенного класса list.

В вашем классе должен быть реализован метод search_by_name, который должен принимать имя и возвращать список всех совпадений.

Создайте экземпляр класса в переменной all_contacts и передайте список ваших контактов.

Примерный ввод:

all_contacts = ContactList(['Ivan', 'Maris', 'Olga', 'Ivan Olya', 'Olya Ivan', 'ivan']) 
print(all_contacts.search_by_name('Olya')) 
Метод search_by_name возвращает все строки содержащие подстроку "Olya":

['Ivan Olya', 'Olya Ivan'] 






















Наследование. Таск 7
Принципы ООП. Наследование.
Задание 7
Создайте класс SmartPhones, экземпляры класса должны иметь такие свойства:

name - название
color - цвет
memory - память
battery - процент заряда батареи
Значение battery по умолчанию должно быть 0.

Переопредилите метод str так чтобы при распечатке он выдавал строку с названием и памятью смартфона.

У данного класса также должен быть метод charge, который увеличивает значение батареи на указанную величину.

Создайте два дочерних класса от Smartphones:

Iphone - с дополнительным аттрибутом экземпляра - ios и методом send_imessage(принимает в аргументы строку и возвращает эту строку и от какого телефона сообщение было выслано в таком формате - sending 'ваша строка' from 'название объекта-телефона')

Samsung - с дополнительным аттрибутом android и методом show_time(который показывает текущее время)

Создайте объекты phone, iphone7, samsung21 от классов SmartPhones, Iphone, Samsung и примените все методы.

Для правильной работы тестов, проделайте все следующие операции:

создайте объект от класса SmartPhones:

phone = SmartPhones('generic', 'blue', '128GB') 
print(phone) 
вывод:

generic 128GB
распечатайте свойство батарейки,затем примените метод charge(), зарядив телефон до 20%:

print(phone.battery) 
phone.charge(20) 
print(phone.battery) 
получим в терминале:

0 
20 
создайте объект от класс Iphone, распечатайте этот объект, и примените метод send_imessage:

iphone7 = Iphone('Iphone 7', 'gold', '128gb', '12.1.3') 
print(iphone7)
print(iphone7.send_imessage('hello')) 
вывод будет:

Iphone 7 128gb 
sending hello from Iphone 7 128gb 
создайте объект от Samsung и примените метод show_time():

samsung21 = Samsung('Samsung A21', 'black', '256gb', 'Oreo') 
print(samsung21.show_time()) 
вывод будет:

18:37:02.712036 






Наследование. Таск 8
Принципы ООП. Наследование.
Задание 8
Напишите класс CustomError который наследуется от встроенного класса исключений Exception.

Переопределите __init__ таким образом чтобы через экземпляр класса можно было передавать сообщение и создавать новые виды исключений.

Создайте исключение от этого класса в переменной capitals_error с сообщением:

ТОЛЬКО БОЛЬШИЕ БУКВЫ РАЗРЕШЕНЫ В ЭТОМ КОДЕ
Напишите функцию check_letters(вне класса, отдельно от класса), проверяющую строки на регистр и если строка не написана в верхнем регистре выбросите исключение созданное классом CustomError:

Traceback (most recent call last):
  File "inheritance.py", line 121, in <module>
    check_letters(a)
File "inheritance.py", line 117, in check_letters
    raise capitals_error
main.CustomError: ТОЛЬКО БОЛЬШИЕ БУКВЫ РАЗРЕШЕНЫ В ЭТОМ КОДЕ 
Если же все хорошо необходимо вывести сообщение: ВСЕ ОТЛИЧНО! {ваша строка}.

Например:

print(check_letters("HELLO")) 
Вывод будет:

ВСЕ ОТЛИЧНО! HELLO 
Если мы применим функцию к этой строке:

print(check_letters("hello")) 
Получим исключение от нашего класса CustomError:

Traceback (most recent call last): 
 File "inheritance.py", line 121, in <module> 
     check_letters(a) 
 File "inheritance.py", line 117, in check_letters 
     raise capitals_error 
__main__.CustomError: ТОЛЬКО БОЛЬШИЕ БУКВЫ РАЗРЕШЕНЫ В ЭТОМ КОДЕ 






Полиморфизм. Таск 1
Принципы ООП. Полиморфизм.
При полиморфизме один и тот же метод может использоваться для объектов от разных классов, при этом результат может меняться в зависимости к какому классу принадлежит объект.

Одним из самых распространенных примеров полиморфизма в Python является оператор + . Напишем простую функцию, складывающую два параметра:

def add(x, y): 
    print(x + y) 
Теперь, используем функцию add для двух строк, двух списков и двух чисел:

add('makers ','bootcamp') 
add([1, True], [3, False]) 
add(1, 2) 
во всех трех случаях наш код отработает корректно, однако в зависимости от того к какому классу, типу данных, принадлежат переданные аргументы, поведение функции меняется.

В терминале получаем вывод:

makers bootcamp 
[1, True, 3, False] 
3 
функция add провела конкатенацию со строками, объединила два списка в один, а числа сложила по значению.

Задание 1
Объявите 3 переменные - a, b и c.

В а запишите строку, в b - список и в с сохраните словарь. Затем запишите все три переменные в список, пройдитесь по нему циклом и распечатайте длину каждого из объектов.

Например:

a = '12342342345' 
b = [1,['a',5,6],2,3,4,5] 
c = {1:'a', 2: {'a': 1, 'b': 2}, 3:'c'} 
Вывод:

11 
6 
3 











Полиморфизм. Таск 2
Принципы ООП. Полиморфизм.
Задание 2
Создайте классы Dog и Cat с одинаковым методом voice.

Для собак он должен печатать "Гав", для кошек "Мяу".

Объявите для каждого из классов по экземпляру, для класса Cat экземпляр в переменной barsik, а для Dog экземпляр rex.

Затем, вне класса объявить функцию to_pet(), которая будет принимать животное и вызывать у него метод voice().

Ввод:

to_pet(barsik) 
to_pet(rex) 
Вывод:

Мяу 
Гав 










Полиморфизм. Таск 3
Принципы ООП. Полиморфизм.
Задание 3
Создайте 3 класса: Person с параметрами name и last_name, Employee с work и status, Student c university и course, при этом Employee и Student должны наследоваться от Person.

Определите во всех трёх классах метод get_info():

для класса Person он должен возвращать следующее: “Привет, меня зовут Иван Петров”.

для класса Employee он должен возвращать: “Привет, меня зовут Иван Петров, я работаю в компании Рога и копыта на должности директор.

для класса Student должно возвращаться: “Привет, меня зовут Иван Петров, я учусь в КГТУ на 3 курсе”.

Вне класса, определите функцию get_human_info(), которая будет принимать объект одного из трёх классов и вызывать у него метод get_info и распечатывать результат этой функции.

Создайте для каждого класса по экземпляру, для Person экземпляр person, для Employee экземпляр employee и student для класса Student.

Вызовите метод get_human_info у каждого экземпляра печатать результат.

Ввод должен быть:

get_human_info(employee) 
get_human_info(student) 
get_human_info(person) 
Вывод:

Привет, меня зовут Иван Петров, я работаю в компании Рога и Копыта на должности директор 
Привет, меня зовут Иван Петров, я учусь в КГТУ на 3 курсе 
Привет, меня зовут Иван Иванов 




Полиморфизм. Таск 4
Принципы ООП. Полиморфизм.
Задание 4
Объявите абстрактный класс геометрических фигур Shape и определите в нём абстрактный метод get_area() для расчёта площади фигуры, которые необходимо переопределить в дочерних классах.

Затем, наследуйте от Shape три класса: Triangle, Square и Circle.

треугольник создаётся с заданными основанием base и высотой height

квадрат создаётся с заданной длиной стороны length

круг создаётся с заданным радиусом radius

Переопределите в каждом из классов метод get_area() таким образом, чтобы он рассчитывал площадь для конкретной фигуры.

Затем, создайте от каждого из трёх классов по экземпляру, и вызовите у каждого метод get_area()

Подсказка: для создания абстрактных классов воспользуйтесь модулем abc - https://docs.python.org/3/library/abc.html

Ввод должен быть:

print(triangle.get_area()) 
print(square.get_area()) 
print(circle.get_area()) 
Вывод:

12.5 
25 
314.1592653589793 





Полиморфизм. Таск 5
Принципы ООП. Полиморфизм.
Задание 5
Создайте класс OS, экземпляры которого имеют аттрибут version - версия системы. От OS наследуйте три класса - Windows, MacOS, Linux.

У всех трех классов должен быть метод copy который принимает в аргументы text и возвращает соответствующую строку.

Создайте экземпляры класса, от Windows - в переменной win, от MacOS - mac, а от Linux в переменной lin.

Примените к каждому объекту метод copy, следующим образом:

Ввод должен быть:

print(win.copy('Полиморфизм — одна из основных парадигм ООП'))
 
print(mac.copy('Полиморфизм - разное поведение одного и того же метода в разных классах')) 
 
print(lin.copy('На самом деле одинаковым является только имя метода, его исходный код зависит от класса'))
Вывод должен быть:

скопирован текст "Полиморфизм — одна из основных парадигм ООП" горячими клавишами CTRL + C
 

скопирован текст "Полиморфизм - разное поведение одного и того же метода в разных классах" горячими клавишами COMMAND + C
 

скопирован текст "На самом деле одинаковым является только имя метода, его исходный код зависит от класса" горячими клавишами CTRL + SHIFT + C








Полиморфизм. Таск 6
Принципы ООП. Полиморфизм.
Задание 6
Создайте класс Language, экземпляры которого имеют такие свойства как level и type. Наследуйте от данного класса два других класса - Python и JavaScript. И у Python, и у JavaScript должно быть два метода:

write_function, принимает такие аргументы как func_name и arg
create_variable, с аргументами var_name, value
Создайте экземпляр от класса Python в переменной py.

Затем, примените методы к экземпляру класса Python:

print(py.write_function('get_code', 'a')) 
print(py.create_variable('name', 'John'))
вывод должен быть такой:

def get_code(a):    
name = 'John'
Создайте экземпляр от класса JavaScript в переменной js.

Примените метод следующим образом:

print(js.write_function('validate', 'form')) print(js.create_variable('password', 'john@123'))
Вывод должен быть таким:

function validate(form) {     }; 
let password = 'john@123'




Полиморфизм. Таск 7
ООП. Полиморфизм.
Таск 7
Создайте класс Money, объекты которого имеют аттрибуты country и symbol.
 Наследуйте от него классы Dollar и Euro.
  У данных методов должна быть переменная класса rate, курс к сому,
  Dollar - 84.80, Euro - 98.40. Добавьте к этим классам метод exchange,
  который принимает количество которое нужно обменять в переменную amount и возвращает такую строку:

$ 100 равен 8480.0 сомам
€ 80 равен 7872.0 сомам











Полиморфизм. Таск 8
ООП. Полиморфизм.
Таск 8
Создайте классы Mercury, Venus, Jupiter, которые наследуют метод __init__ от родительского класса Planet. У объектов данного класса должен быть аттрибут orbit, орбита в классе Venus состовляет 225 земных дней, Mercury 88 земных дней, а на Jupiter 12 дней. У всех этих классов должен быть метод get_age, принимающий возраст в переменную earth_age и расчитывающий ваш возраст на данной планете.

Метод должен возвращать возраст на Mercury в годах, на Venus в днях и на Jupiter в часах. Например, если возраст earth_age равен 20:

на Венере ваш возраст составляет 11842 дней
на Юпитере ваш возраст составляет 5326080 часов
на Меркурии ваш возраст составляет 82 лет











Инкапсуляция. Таск 1
Инкапсуляция.
С помощью инкапсуляции можно ограничить доступ к атрибутам и методам внутри класса.

В Python существует три вида "защиты": публичный, защищенный и приватный.

К публичному виду относятся все элементы класса по умолчанию, то есть здесь инкапсуляция отсутсвует.

К защищенному виду относятся атрибуты и методы с одним подчеркиванем в начале названия атрибута или метода:

class A: 
  def _protected(self): 
      print('защищен') 
однако, если мы создадим объект от данного класса и вызовем метод _protected:

a = A() 
a._protected() 
то в терминале все равно получим вывод:

защищен 
Данный вид инкапсуляции, в Python, работает на уровне соглашения между разработчиками,
 т.е на самом деле Python, никак не скрывает и не защищает ваши методы и атрибуты.

Но вы можете поставить одно подчеркивание перед названием, чтобы дать понять другим программистам
 которые будут использовать ваш код, что данный элемент изменять нельзя.

Приватные методы и атрибуты создаются двумя нижними подчеркиваниями до названия метода или атрибута.

Например:

class A: 
  def __private(self): 
      print('приватный') 
если мы создадим объект и попытаемся вызвать такой метод:

a = A() 
a.__private() 
в терминале уже получим исключение:

AttributeError: 'A' object has no attribute '__private' 
Задание 1
Создайте класс A и объявите в нём 3 метода:

публичный(public) (возвращает строку 'Public method'),
защищённый(protected) (возвращает строку 'Protected method')
приватный(private) (возвращает строку 'Private method')
Затем создайте экземпляр в переменной obj1 данного класса и вызовите (с выводом в терминал) по очереди каждый из методов. Не забудьте,
 что нужно вызвать приватный метод так, чтобы ошибка не выводилась
















Инкапсуляция. Таск 2
Инкапсуляция.
Задание 2
Определите класс A, в нём объявите метод method1, который печатает строку "Hello World".

Затем, создайте класс B, который будет наследоваться от класса A.

Создайте экземпляр в переменной b1 от класса B, и через него вызовите метод method1.










Инкапсуляция. Таск 3
Инкапсуляция.
Несмотря на то что, при вызове приватных методов и атрибутов мы получали в терминале исключения, такую инкапсуляцию в Python также можно обойти. Для этого используют getters и setters методы.

На самом деле getters и setters методы представляют из себя самые обыкновенные методы внутри класса, в которых мы прописываем такую логику, с помощью которой сможем получить тот или иной приватный атрибут.

getter(геттер) - это любой метод, с помощью которого мы можем получить значение приватного атрибута

setter(сеттер) - это любой метод, с помощью которого мы можем изменить значение приватного атрибута

К примеру, у нас есть класс Phone, у объектов класса есть приватное свойство - __passcode, пароль от телефона:

class Phone: 
def __init__(self, passcode): 
    self.__passcode = passcode 
напишем для данного атрибута геттер и сеттер:

class Phone: 
def __init__(self, passcode): 
    self.__passcode = passcode

def get_passcode(self): 
    return self.__passcode
    
def set_passcode(self, new): 
    self.__passcode = new 
методы геттеры и сеттеры могут называться как угодно, но для ясности часто перед началом названия метода добавляют get, либо set.

get_passcode - наш getter метод, возвращает значение атрибута __passcode в обход защиты.

set_passcode - устанавливает новое значение атрибуту, которое передается в переменную new.

Создадим объект от данного класса, изменим пароль с помощью set_passcode и вызовем get_passcode:

myphone = Phone(1234) 
myphone.set_passcode(9876) 
print(myphone.get_passcode()) 
Получим в терминале новое значение:

9876 
Зачем мы используем getters и setters?

с помощью getters и setters можно установить разные уровни доступа, 
к примеру с помощью условного ветвления if...else можно установить доступ к атрибутам в зависимости от выполнения условий.

таким способом можно скрыть структуру кода, представления атрибутов,
 т.е посторонние не увидят как реализован тот или иной атрибут, но смогут получить значение атрибута.

можно добавить логику проверки для получения и установки значения.

можно поддерживать единый интерфейс на случай изменения внутренних элементов, т.е можно контроллировать изменения извне.

Задание 3
Объявите класс Car, в котором будет приватный атрибут экземпляра класса speed.

Затем, определите метод set_speed, который будет устанавливать значение скорости и метод show_speed,
 который возвращает значение скорости.

Создайте экземпляр в переменной car1 класса Car и вызовите все методы.

Ввод:

car1 = Car() 
print(car1.show_speed()) 
car1.set_speed(20) 
print(car1.show_speed()) 
Вывод:

0 
20 








Инкапсуляция. Таск 4
Инкапсуляция.
Для удобства, в инкапсуляции существует два декоратора для setters - @название.setters, а для getters - @property.

С помощью данных декораторов можно имитировать обычное присваивание нового значение атрибуту через знак равно и доступ к значению атрибута через точку для приватных атрибутов.

То есть они будут работать также, как будто бы и не были защищены:

obj.атрибут  
     #выведет значение  
obj.атрибут = 'hello!'  
     #установит новое значение атрибуту объекта 
Перепишем методы нашего класса Phone через данные декораторы:

class Phone: 
  def __init__(self, passcode): 
      self.__passcode = passcode 
 
  @property 
  def code(self): 
      return self.__passcode

  @code.setter 
  def code(self, new): 
      self.__passcode = new  
Обычно, Python не допускает создание функций с одинаковым названием,
но в инкапсуляции для того чтобы наши декораторы работали корректно, 
оба метода и setter и getter должны иметь одно название.

Для декоратора @property достаточно просто добавить его над методом, который отвечает за получение значения.

Для декоратора @название.setter, в начале нужно прописать название функции,
 к примеру если функция называется func, то декоратор будет выглядеть таким образом - @func.setter.

Создадим объект от класса и посмотрим как применяются декорированные методы:

myphone = Phone(1234) 
print(myphone.code) 
как мы видим, для получения приватного атрибута,
 теперь достаточно просто указать название объекта и через точку указать название атрибута, в терминале получим:

1234 
если же мы хотим установить новое значение, делается это также как если бы мы присваивали новое значение обычному(публичному) атрибуту:

myphone.code = 4321 
print(myphone.code) 
в терминале получим:

4321 
Помним что, основная цель любого декоратора - изменить методы или атрибуты вашего класса таким образом,
 чтобы вам не нужно было вносить какие-либо изменения в свой код.

Задание 4
Перепишите класс Car из предыдущего задания.

Перепишите метод set_speed() с использование декоратора @speed.setter, а метод show_speed() с использованием декоратора @property.

Создайте обьект car1 класса Car.

Ввод:

car1 = Car() 
print(car1.speed) 
car1.speed = 20 
print(car1.speed) 
Вывод:

0 
20 













Инкапсуляция. Таск 5
Задание 5
Создайте класс Person и объявите в нем 3 атрибута класса: name (public), phone_number(protected) и сard_number(private),
Атрибуты класса будут равны следующим значениям: "John", "+996 557 55 17 57" и "9999 9999 9999 9999".
Создайте объект 'john' класса Person и выведите на экран все атрибуты класса.











Инкапсуляция. Таск 6
Задание 6
Создайте класс Person у которого будут следующие атрибуты экземпляра класса: name (public), phone_number(protected) и сard_number(private).
Создайте экземпляр "john" класса Person со значениями ("John", "+996 557 55 17 57" и "9999 9999 9999 9999") и выведите на экран все его атрибуты.









Инкапсуляция. Таск 7
Задание 7
Снова создайте класс Person и объявите в нем 3 атрибута: name (public), phone_number(protected) и сard_number(private), атрибуты класса будут равны следующим значениям: "John", "+996 557 55 17 57" и "9999 9999 9999 9999".
Создайте объект "john" класса Person и измените все атрибуты экземпляра класса на значение None после выведите все атрибуты этого экземпляра класса.









Инкапсуляция. Таск 8
Задание 8
Продолжая изменять логику предыдущего задания создайте класс Person у которого будут следующие атрибуты экземпляра класса: name (public), phone_number(protected) и сard_number(private).
При инициализации объекта проверяйте введенные имя. Для этого напишите приватный метод validate_name для валидации имени: данный метод будет проверять длину имени, если длина имени меньше двух то возвращайте имя по дефолту John,
Если же введенное пользователем имя больше двух, то необходимо возвращать имя с заглавной буквы (JOHN -> John, john -> John и тд).
Создайте экземпляр sam класса Person со значениями ("SAM", "+996 557 55 17 57" и "9999 9999 9999 9999") и выведите на экран все его атрибуты






Инкапсуляция. Таск 9
Задание 9
На этот раз заказчик передумал и попросил вас переписать предыдущий класс, теперь его интересует только валидация номера телефона и номера карты.
Создайте класс Person у которого будут следующие атрибуты экземпляра класса: name (public), phone_number(protected) и сard_number(private). При инициализации объекта проверяйте введенный номер телефона и номер карты.
Для этого напишите защищенный метод validate_phone_number и приватный метод validate_card_number.
Метод validate_phone_number в первую очередь проверяет на то что бы номер был объектом от класса int иначе возвращаем None, во вторую - начинался с 996 *Метод validate_card_number в первую очередь также проверяет на то что бы номер карты был объектом от класса int иначе возвращаем None, далее нужно также проверять чтобы количество цифр в номере карт было ровно 16 иначе также возвращаем None.
Создайте экземпляр tolik класса Person c правильными данными и выведите на экран все его атрибуты






Инкапсуляция. Таск 10
Задание 10
Необходимо написать класс Game у которого есть приватный атрибут класса "level" который равен нулю и 
атрибут экземпляра класса name (ваше имя).
Класс Game должен иметь методы для увеличения уровня игры (play) и получения текущего уровня (get_level).
Метод play принимает в себя переменную hours и проверяет если значение этой переменной больше двух 
то уровень игры увеличивается на единицу иначе ничего не происходит. 
Так как атрибут класса "level" приватный и по
этому недоступен извне, необходимо реализовать метод "get_level" который возвращает значение атрибута "level".
Создайте экземпляр "game" класса Game.
 Выведите на экран значение атрибута "level" затем два раза используйте метод play чтобы уровень игры поднялся на два,
  после снова выведите на экран значение атрибута "level".








Инкапсуляция. Таск 11
Задание 11
Необходимо написать класс Game у которого есть приватный атрибут класса "level" который равен нулю и атрибут экземпляра класса name (ваше имя).
Класс Game должен иметь два метода: "set_level" и приватный метод "validate_name".
При инициализации экземпляра класса вызывается приватный метод validate_name который возвращает имя в котором первая буква в верхнем регистре, а остальные в нижнем (JOHN -> John).
Также в классе необходимо реализовать метод "set_level" который принимает в себя переменную "level" и увеличивает значение приватного атрибута класса "level" на значение этой переменной которую передали только в том случае если имя объекта (который сейчас играет в эту игру) "Tolik", иначе выведите на экран
"имя_объекта" ты не Tolik!'.
Создайте сначала экземпляр класса "game" и передайте ему имя Raychel в качестве аргумента. Далее вызовите метод set_level и передайте ему значение 5. После выведите в терминал значение атрибута "level" (так как у нас не реализован метод get_level, выведите это "нелегальным" способом). Теперь создайте экземпляр класса game2 и передайте ему имя "TOLIK" в качестве аргумента. Далее вызовите метод set_level и передайте ему значение 5. После выведите в терминал значение атрибута "level" (так как у нас не реализован метод get_level, выведите это "нелегальным" способом).
Ожидаемый вывод:

Raychel ты не Tolik!
0
5








Инкапсуляция. Таск 12
Задание 12
Необходимо написать класс Game у которого есть приватный атрибут класса level который равен нулю и атрибут экземпляра класса name (ваше имя).
Так как атрибут класса level приватный и поэтому недоступен извне, необходимо реализовать два метода для работы с ним: get_level и set_level. Где get_level возвращает значение атрибута level и set_level принимает значение и присваивает его атрибуту level.
Создайте экземпляр game класса Game. Выведите на экран значение атрибута level затем присвойте ему значение 10 и выведите его на экран.









Инкапсуляция. Таск 13
Задание 13
Необходимо написать класс Game у которого есть приватный атрибут класса level который равен нулю. 
Напишите метод level с использование декоратора @property для предоставления доступа к атрибуту level.
Создайте экземпляр game класса Game. Выведите на экран значение атрибута level.







Инкапсуляция. Таск 14
Задание 14
Необходимо написать класс Game у которого есть приватный атрибут класса level который равен нулю. 
Напишите метод level с использованием декоратора @setter для того чтобы вы имели право на изменение приватного атрибута 
класса level вне класса Game. Но обратите внимание что вы не сможете написать этот метод без метода level у которого используется
декоратор @property, поэтому также создайте этот метод.
Создайте экземпляр game класса Game. Выведите на экран значение атрибута level, после 'легально' 
измените значение level на 10 и снова выведите это значение на экран.





Инкапсуляция. Таск 15
Задание 15
Напишите класса Person, который будет хранить информацию о пользователе. У объекта будут следующие атрибуты экземпляра класса: имя(name), фамилия(last_name), возраст(age), почта (email).
При инициализации объекта, передавать аргументы классу не нужно, все его атрибуты по умолчанию будут равны None и также все они будут приватными.
Поэтому реализуйте для каждого атрибута методы доступа get и set не используя декораторы property и setter. У вас будут такие методы: get_name, set_name, get_last_name, set_last_name, get_age, set_age, get_email, set_email.
Создайте экземпляр john класса Person выедите все его атрибуты, затем измените их как показано ниже и после снова выведите на экран.
Пример:

john = Person()
print(john.get_name()) # None
print(john.get_last_name()) # None
print(john.get_age()) # None
print(john.get_email()) # None
john.set_name('John')
john.set_last_name('Snow')
john.set_age(30)
john.set_email('johnsnow@gmail.com')
print(john.get_name()) # John
print(john.get_last_name()) # Snow
print(john.get_age()) # 30
print(john.get_email()) # johnsnow@gmail.com







Инкапсуляция. Таск 16
Задание 16
Перепишите предыдущий класс используя декораторы property и setter.
Условие: Реализуйте класс Person, который будет хранить информацию о пользователе. У обьекта будут следующие атрибуты экземпляра класса: имя(name), фамилия(last_name), возраст(age), почта (email). При инициализации объекта, передавать аргументы классу не нужно, все его атрибуты по умолчанию будут равны None и также все они будут приватными. Поэтому реализуйте для каждого атрибута методы доступа get и set с помощью декораторов которые вы прошли.
Создайте экземпляр john класса Person выведите все его атрибуты, затем измените их как показано ниже и после снова выведите на экран.
Пример:

john = Person()
print(john.name) # None
print(john.last_name) # None
print(john.age) # None
print(john.email) # None
john.name = 'John'
john.last_name = 'Snow'
john.age = 30
john.email = 'johnsnow@gmail.com'
print(john.name) # John
print(john.last_name) # Snow
print(john.age) # 30
print(john.email) # johnsnow@gmail.com
Согласитесь что этот способ c использованием декораторов позволяет писать более понятный и элегантный код











Инкапсуляция. Таск 17
Задание 17
Реализуйте класс Dad у которого будут следующие атрибуты класса: name который равен 'John', защищенный атрибут last_name который равен 'Snow' и приватный атрибут age равный 40.
Затем реализуйте класс Me, который будет наследоваться от класса Dad и будет содержать атрибуты name равный 'Sam', защищенный атрибут last_name равный фамилии отца и приватный атрибут age равный 10.
Также реализуйте 2 метода: about_me который выводит информацию об этом объекте в виде:
'My name is Sam Snow and I am 10 years old'
И about_dad который выводит информацию об этом обьекте в виде:
'My father is John Snow'. 
(Обратите внимание что в методе about_father мы не выводим атрибут age объекта отца, как этот атрибут приватный а это значит что он не будет доступен в дочерних классах).
Создайте экземпляр me класса Me и вызовите методы объекта (их два). Ожидаемый результат:
My name is Sam Snow and I am 10 years old
My father is John Snow









Множественное наследование и миксины. Таск 1
Множественное наследование и миксины.
В Python, классы могут наследоваться сразу от нескольких родительских классов.

При этом методы и атрибуты родительских классов также как при обычном наследовании будут доступны дочернему классу.

Например, у нас есть два класса - электроавтомобили - ElectricCar и обычные авто - RegularCar,
 наследуя от этих двух классов можем создать новый класс гибридных машин - Hybrid:

class ElectricCar: 
     def use_batteries(self): 
         print('использую электричество') 

class RegularCar: 
     def use_gasoline(self): 
         print('использую бензин') 

class Hybrid(ElectricCar, RegularCar): 
     pass 
У родительских классов есть методы use_batteries и use_gasoline, которые теперь доступны и в дочернем классе Hybrid.
 Создадим экземпляр от гибридного класса и вызовем методы родителей:

car = Hybrid() 
car.use_batteries() 
car.use_gasoline() 
в терминале получим:

использую электричество 
использую топливо 
Задание 1
Создайте класс Auto в нем реализуйте метод ride который выводит сообщение 'Riding on a ground'.

Создайте класс Boat реализуйте метод swim, который выводит 'Floating on water'.

Создайте класс Amphibian который наследуется от класса Auto и Boat.

Создайте от него объект obj и вызовите все методы.

Ввод:

obj = Amphibian() 
obj.ride() 
obj.swim() 
Вывод:

Riding on a ground 
Floating on water 





Множественное наследование и миксины. Таск 2
Множественное наследование и миксины.
Миксины, или классы-примеси, это особый вид множественного наследования.

Задачей миксинов является расширение функционала других классов(например новые методы),
 но при этом, миксины не предназначены для
создания от них объектов.

В качестве аналогии, рассмотрим данный пример:

class Borsh: 
     pass

class Salad: 
     pass 
у нас есть два класса для борща и салата, 
к этим двум классам можем написать миксины для соли - SaltMixin и перца - PepperMixin:

class SaltMixin: 
     def salt(self): 
         print('посолили') 

class PepperMixin: 
     def pepper(self): 
         print('поперчили')
 
class Borsh(SaltMixin, PepperMixin): 
     pass  
class Salad(SaltMixin): 
     pass 
в зависимости от того от какого миксина наследуются наши классы,
 объекты созданные от класса Borsh и Salad будут иметь доступ к методам salt и pepper:

sup = Borsh() 
sup.salt() 
sup.pepper() 
в терминале получим:

посолили 
поперчили 
При этом, блюда необязательно солить или перчить, 
это все делается по выбору, на свой вкус
. Также и с миксинами, данные классы необязательны, и не предоставляют основной, критический функционал.

Миксины используют для добавления дополнительных свойств и методов к классу.

Подытожа, можно сказать что миксины используются в таких случаях:

если нужно предоставить классу несколько дополнительных, но необязательных функций
если нужно использовать одно свойство или метод в нескольких разных классах
Задание 2
Создайте класс-миксин RadioMixin, и реализуйте в нем метод для проигрывания музыки play_music,
который принимает в переменную title название песни.

Метод должен печатать строку "Песня называется title", где вместо title должно быть переданное название песни.

Создайте класс Auto, Boat, Amphibian и расширьте функционал этих классов при помощи миксина.
 Класс Amphibian также как в предыдущем задании должен наследоваться от классов Auto и Boat.
  Создайте экземпляры auto, boat и obj от трех классов и примените метод play_music.













Множественное наследование и миксины. Таск 3
Множественное наследование и миксины.
Узнав про такой принцип ООП как полиморфизм, мы понимаем что у нескольких разных классов могут быть одинаковые методы.

Что происходит в таком случае с классом который наследуется от нескольких других классов?

Например, у нас есть два класса А и B, в обоих классах есть метод method, также есть третий класс С который наследуется от классов А и B:

class A: 
     def method(self): 
         print('метод класса А')

class B: 
     def method(self): 
         print('метод класса B')

class C(A,B): 
     pass 
По принципу множественного наследования, класс С должен получить все методы и свойства родительских классов -А и B.

Но так как, и у А и у B есть метод с одинаковым названием method, потенциально это должно приводить к ошибке, так как в одном классе С не может существовать двух методов с одним и тем же названием.

Python обходит такую конфликтную ситуацию, таким образом, в начале поиск указанного метода ведется в первом указанном родителе, т.е класс А, если в классе А действительно есть метод под названием method, то дочерний класс С, наследует данный метод от А, если же его нет поиск метода ведется в классе B и так по порядку, пока метод не будет найден.

Создадим объект от класса С и вызовем метод method:

c = C() 
c.method() 
получим в терминале:

метод класса А 
Поиск метода проводится правильно, а теперь попробуем удалить метод из класса А и снова запустить код:

class A: 
     pass

class B: 
     def method(self): 
         print('метод класса B') 

class C(A,B): 
     pass 

c = C() 
c.method() 
получим в терминале:

метод класса B 
Python не найдя метод в первом родительском классе, перешел ко второму родителю - к классу B и унаследовал данный метод от класса B.

Задание 3
Будильник. Создайте класс Clock, у которого будет метод current_time показывающий текущее время и класс Alarm, 
с методами on и off для включения и выключения будильника.

Далее, создайте класс AlarmClock, который наследуется от двух предыдущих классов.

Добавьте к нему метод alarm_on для установки будильника, при вызове которого должен включатся будильник.

Создайте экземпляр clock класса AlarmClock и примените к ниму методы current_time и alarm_on.

Ввод должен быть:

clock.current_time() 
clock.alarm_on() 
С выводом:

17:10:41 
Будильник включен 







Множественное наследование и миксины. Таск 4
Множественное наследование и миксины.
Задание 4
Напишите абстрактный класс Coder с атрибутом класса count_code_time = 0 и абстрактными методами get_info и coding.

Создайте классы Backend и Frontend, которые наследуют все атрибуты и методы от класса Coder.

Класс Backend должен принимать дополнительно параметры experience и languages_backend, 
а Frontend такие параметры как — experience и languages_frontend соответственно.

Переопределите в обоих классах методы get_info и coding так,
 чтобы он принимал количество часов кодинга и при каждом вызове этого метода добавлял это значение к count_code_time.

Также бывают Fullstack разработчики, поэтому создайте данный класс так чтобы у него были атрибуты и методы предыдущих классов.
 При этом нее определяйте никаких методов и атрибутов в данном классе он должен наследовать их от родительских классов.

Создайте экземпляры a, b, c от классов Backend, Frontend, Fullstack соответственно и вызовите их методы.

Ввод должен быть:

a.coding(12) 
b.coding(45) 
c.coding(17) 
print(a.get_info()) 
print(b.get_info()) 
print(c.get_info()) 
Вывод:

Python разработчик, уровень: Junior, потрачено 12 часов на программирование

Javascript разработчик, уровень: Middle, потрачено 45 часов на программирование

Python and JS разработчик, уровень: Senior, потрачено 17 часов на программирование 






Множественное наследование и миксины. Таск 5
Множественное наследование и миксины.
В предыдущем примере, мы рассмотрели как ведется поиск методов и атрибутов во множественном наследовании. Формально такой поиск называют МRO - method resolution order, порядок разрешения методов(атрибуты тоже попадают под это правило).

Допустим, у нас есть классы с множественным наследованием:

class Grandpa: 
     pass 
class Grandma: 
     pass 
class Dad(Grandpa, Grandma): 
     pass 
class Mom: 
     pass 
class Me(Dad, Mom): 
     pass 
Класс Me наследуется от классов Dad и Mom, класс Dad в свою очередь наследуется от классов Grandpa, Grandma.

При поиске методов и атрибутов, для самого младшего класса Me, мы знаем что Python в начале будет искать в самом классе Me, затем перейдет к первому родителю - Dad.

Если же метод или атрибут не будет найден, далее будет производится поиск в родительских классах класса Dad, также начиная с первого указанного родителя, т.е в Grandpa, затем в Grandma.

Проверив всю ветку класса Dad, только в случае если запрашиваемый метод и атрибут не были найдены, Python начнет поиск во втором родительском классе класса Me - Mom.

Для того, чтобы подвтердить это, можем распечатать встроенный атрибут __mro__ и у класса Me:

print(Me.__mro__) 
получим в терминале запись:

(<class '__main__.Me'>, <class '__main__.Dad'>, <class '__main__.Grandpa'>, <class '__main__.Grandma'>, <class '__main__.Mom'>, <class 'object'>) 
в самом конце поиск методов и атрибутов проводится в классе object, который является базовым классом от которого наследуются все созданные нами классы.

Задание 5
Создайте два класса: Square и Triangle.

Класс Square должен иметь атрибуты: side - длина стороны квадрата.

Класс Triangle должен иметь аттрибуты: height - высота, base - длина.

У каждого из вышеуказанных классов должен быть метод get_area, который высчитывает и возвращает площадь - результатом должно быть целое число.

Создайте третий класс Pyramid который наследуется от первых двух классов, init унаследуйте от Triangle, дополнительные аттрибуты присваивать нельзя.

Добавьте метод get_volume для расчета объема пирамиды(формула: 1/3 x основание^2 x высоту), метод должен возвращать целое число.









Множественное наследование и миксины. Таск 6
Множественное наследование и миксины.
Задание 6
Создайте класс ToDo, с аттрибутом класса, в виде словаря todos = {}.

У класса должен быть один метод set_deadline, который принимает дату дедлайна (в виде "31/12/2021") и возвращает количество дней оставшихся до дедлайна.

Также, класс ToDo должен наследоваться от четырех миксинов: CreateMixin, DeleteMixin, UpdateMixin, ReadMixin:

в классе CreateMixin определите метод create, который принимет в себя задачу todo и ключ key по которому нужно добавить задачу в словарь todos, если ключ уже существует верните "Задача под таким ключом уже существует".

класс DeleteMixin должен содержать метод delete, который удаляет задачу по ключу key, который передается как аргумент, и возвращает сообщение 'удалили название задачу', где вместо слова название должно быть название задачи.

класс UpdateMixin должен содержать метод update, который принимает в себя ключ key и новое значение new_value и заменяет задачу под данным ключом на новое значение.

класс ReadMixin должен содержать метод read, который возвращает отсортированный список задач.









Множественное наследование и миксины. Таск 7
Множественное наследование и миксины.
Задание 7
Напишите класс Game, с помощью которого можно создать объекты-игры, у объектов должны быть атрибуты:

type_ - тип игры
name - название игры,
extensions соответсвующий пустому списку - [].
У класса должны быть методы:

get_description, который принимает строку и возвращает описание к игре в виде названия игры и переданной строки:
Minecraft это инди-игра в жанре песочницы с элементами выживания и открытым миром. 
Где Minecraft - это название игры, берется из атрибута name объекта.

get_extensions, который возвращает все подключенные расширения в виде строки разделенной пробелами, если же список extensions пуст, возвращайте сообщение:
Нет подключенных расширений   
Также напишите миксин ExtensionMixin, чтобы к игре можно было подключать расширения.

У миксина должно быть два метода:

add_extension, принимающий строку-название и добавляющий ее в список игры, также должен возвратить сообщение:
Добавлено новое расширение Multiverse-Core для игры Minecraft. 
где Multiverse-Core это строка - название расширения

remove_extension, удаляющий расширение по названию, и возращающий строку в формате:
Multiverse-Core был отключен от Minecraft. 
Если же такого расширения нет в списке должна возвращаться строка:

Такого расширения нет в списке.








Множественное наследование и миксины. Таск 8
Таск 8
Создайте класс WalkMixin с методом walk, который будет выводить "я могу ходить"

Создайте класс FlyMixin с методом fly, который будет выводить "я могу летать"

Создайте класс SwimMixin с методом swim, который будет выводить "я могу плавать"

Создайте класс Human, который будет наследоваться от миксинов WalkMixin и SwimMixin
Создайте класс Fish, который будет наследоваться от миксина SwimMixin
Создайте класс Exocoetidae, который будет наследоваться от миксинов FlyMixin и SwimMixin
Создайте класс Duck, который будет наследоваться от всех 3 миксинов
Создайте обьекты от классов Human, Fish, Exocoetidae, Duck и вызовите методы, которые у них есть от миксинов















PostgreSQL. Task 1
Найдите 10 самых часто встречающихся слов из таблицы wordform. Ожидаемый вывод:

plaintext    
-----------   
the    
and    
i    
to    
of    
a    
you    
...   
(10 rows)  















PostgreSQL. Таск 2
Найдите все слова, которые начинаются с буквы a(таблица wordform),

регистр не должен иметь значения.

Ожидаемый вывод:


plaintext       
-------------------   
and   
a   
as   
all   
are   
at   
am   
...  
(1569 rows) 










PostgreSQL. Таск 3
Выведите название всех произведений, которые относятся к жанру p(таблица work).

Ожидаемый вывод:

| title | genretype |
| Lover's Complaint      | p | 
--------------------------------
| Passionate Pilgrim     | p | 
--------------------------------
| Phoenix and the Turtle | p | 
--------------------------------
| Rape of Lucrece        | p | 
--------------------------------
| Venus and Adonis       | p | 
--------------------------------
(5 rows)









PostgreSQL. Таск 4
Найдите среднее количество параграфов в произведениях жанра t (таблица work).

Ожидаемый вывод:


avg      
---------------------- 
1070.8181818181818182  
(1 row) 









PostgreSQL. Таск 5
Выведите названия всех произведений из таблицы work, в которых количество слов выше среднего.

Ожидаемый вывод:


title             
---------------------------   
All's Well That Ends Well   
Antony and Cleopatra   
As You Like It   
Coriolanus   
Cymbeline   
Hamlet   
Henry IV, Part I   
...  
(28 rows) 





PostgreSQL. Таск 6
Выведите имя героя, количество его реплик и название произведения, в котором этот герой встречается(таблицы character_work и character).

Ожидаемый вывод:

   charname         | speechcount |     title            
--------------------+-------------+------------------------ 
First Apparition    |           1 | Macbeth 
First Citizen       |           3 | Romeo and Juliet 
First Conspirator   |           3 | Coriolanus 
First Gentleman     |           1 | Othello 
First Goth          |           4 | Titus Andronicus 
... 
(1346 row) 









PostgreSQL. Таск 7
Выведите среднее количество реплик героев в произведении 'Romeo and Juliet' (таблицы character_work и work).

Ожидаемый вывод:

round |      title          
-------+------------------      
   26 | Romeo and Juliet  
(1 row) 








PostgreSQL. Таск 8
Выведите общее количество слов в каждой из секций в таблице paragraph.

Ожидаемый вывод:

section |  sum     
---------+--------         
      0 |   2963         
      1 | 219622         
      3 | 174015         
      5 | 148638         
      4 | 168204        
      2 | 170774  
(6 rows) 







PostgreSQL. Таск 9
Выведите имя и количество реплик героев, у которых от 15 до 30 реплик (таблица character).

Ожидаемый вывод:

   charname    | speechcount   
----------------+-------------   
First Murderer |          21   
First Witch    |          23   
Second Witch   |          15   
Aegeon         |          17   
Aemilia        |          16   
Agrippa        |          28   
Alexas         |          15   
...  
(153 rows)









PostgreSQL. Таск 10
Выведите название и год написания всех произведений, которые были написаны в 17 веке (таблица work).

Ожидаемый вывод:

          title           | year   
---------------------------+------   
All's Well That Ends Well | 1602   
Antony and Cleopatra      | 1606   
Coriolanus                | 1607   
Cymbeline                 | 1609   
Henry VIII                | 1612   
King Lear                 | 1605   
Lover's Complaint         | 1609   
...  
(17 rows) 


PostgreSQL. Таск 11
Выведите полные названия всех произведений, которые имеют в полном названии слово the (таблица work).

Поиск должен быть чувствителен к регистру(только для the с маленькими буквами).

Ожидаемый вывод:

longtitle                  
----------------------------------------   
The Tragedy of Othello, Moor of Venice   
The Phoenix and the Turtle   
The Taming of the Shrew   
The Tragedy of Timon of Athens  
(4 rows) 





PostgreSQL. Таск 12
Выведите все уникальные секции в paragraph.

Ожидаемый вывод:

section   
---------         
0         
1         
3         
5         
4         
2  
(6 rows) 







PostgreSQL. Таск 13
Для каждой главы выведите: chapterid, описание и название произведения, к которой относится данная глава (таблицы chapter и work).

Ожидаемый вывод:

chapterid |      description      |   title     
-----------+-----------------------+--------------   
    18934 | Prologue.             | Henry V       
    18704 | DUKE ORSINO's palace. | Twelfth Night       
    18705 | The sea-coast.        | Twelfth Night       
    18706 | OLIVIA'S house.       | Twelfth Night       
    18707 | DUKE ORSINO's palace. | Twelfth Night       
    18708 | OLIVIA'S house.       | Twelfth Night       
    18709 | The sea-coast.        | Twelfth Night   
...  
(945 rows) 






PostgreSQL. Таск 14
Для каждого параграфа выведите: номер параграфа, имя героя, и количество реплик героя (таблицы paragraph и character).
Ожидаемый вывод:

paragraphnum |      charname      | speechcount   
--------------+------------------- +-------------              
           3 | (stage directions) |         126              
           4 | Orsino             |          59             
          19 | Curio              |           4             
          20 | Orsino             |          59             
          21 | Curio              |           4             
          22 | Orsino             |          59             
          30 | Valentine          |           3   
...  
(35465 rows) 








PostgreSQL. Таск 15
Для каждого параграфа выведите: номер параграфа, название произведения и год выхода этого произведения (таблицы paragraph и work).

Ожидаемый вывод:

paragraphnum |           title           | year   
--------------+---------------------------+-----              
           3 | Twelfth Night             | 1599              
           4 | Twelfth Night             | 1599             
          19 | Twelfth Night             | 1599             
          20 | Twelfth Night             | 1599             
          21 | Twelfth Night             | 1599             
          22 | Twelfth Night             | 1599             
          30 | Twelfth Night             | 1599   
...  
(35465 rows) 





"""shakispir-psql"""













Декораторы. Таск 1
Декораторы.
Декораторы называют функциями высшего порядка, так как декораторы принимают в аргументы декорируемую функцию и возвращают функцию в качестве результата работы(в return).

Синтаксис декораторов выглядит данным образом:

def имя_декоратора(функция): 
  def функция_обертка(): 
       # код дополняющий функцию 
       # может быть вызов функции() 
       # здесь может быть код после вызова функции  
  return функция_обертка  
Наш декоратор принимает в аргументы функцию, зачем же тогда нам нужна еще одна внутренняя функция-обертка?

Суть декораторов состоит в том чтобы изменить поведение функции, не изменяя саму функцию, т.е декоратор принимает функцию, обрабатывает внутри и в конечном итоге должен возвратить обработанную функцию. Именно для возвращения измененной функции нам нужна функция-обертка.

Задание 1
Напишите декоратор call_function, который печатает перед вызовом полученной функции строку:

 Вызываю функцию <имя_функции>
Затем следует вызов функции. После вызова функции должна печататься строка:

 "Вызов функции <имя_функции> прошёл успешно"
Ввод:

@call_function
def first():
    print("hello world")
    return "hello world"
first()
Вывод:

Вызываю функцию first
hello world 
Вызов функции first прошёл успешно 









Декораторы. Таск 2
Декораторы.
Задание 2
Создайте декоратор func_start_time, который будет распечатывать дату и время вызова принимаемой функции, а затем вызывает саму функцию, например:

@func_start_time
def func():
    print('Hello world')
func()
Вывод:

Функция запущена 26.02.2021 21:51
Hello World
Для этого воспользуйтесь модулем datetime.



Декораторы. Таск 3
Декораторы.
К функции можно применять неограниченное количество декораторов. В этом случае порядок применения декораторов будет иметь значение. Декоратор который находится ближе к функции будет выполняться первее.

К примеру:

@check_the_speed 
@check_is_true 
def my_func(): 
  return True 
в начале функцию обработает декоратор @check_is_true, который возвратит обработанную функцию my_func, затем к результату работы данного декоратора применится декоратор @check_the_speed.

Задание 3
Создайте 3 декоратора, каждый из которых применяет к тексту определённый стиль:

выделение жирным <b>...</b> (декоратор make_bold)

курсив <i>...</i> (декоратор make_italic)

подчеркивание <u>...</u> (декоратор make_underline)

Далее создайте функцию hello которая будет возвращать текст

Hello world
примените к этой функции цепочку декораторов.

@make_bold
@make_italic
@make_underline
def hello():
    return 'Hello world'
 
print(hello())
Вывод должен быть:

<b><i><u>Hello world</u></i></b>





def make_bold(func):
    ... 


def make_italic(func):
    ...


def make_underline(func):
    ...




Декораторы. Таск 4
Декораторы.
Внутри декоратора можно прописать дополнительный код как до вызова функции так и после. Помним, что внутри функции работает любой код написанный до ключевого слова return.
В такой конструкции:

import time 
def decorator(func): 
    def wrapper(): 
        print(time.time()) 
        func() 
        print('Закончил работу') 
    return wrapper  
в начале распечатается время print(time.time) - здесь используется еще один модуль для работы с временем time, который также нужно импортировать.

Затем, запускается функция func(), декоратор будет ждать окончания работы func(), и только когда в func() запустится весь код, сработает print('Закончил работу')

Задание 4
Создайте декоратор benchmark, замеряющий время выполнения функции в секундах и выводящий строку например:

Время выполнения: 0.05 секунд.
Затем объявите функцию fetch_webpage, которая выполняет GET-запрос на главную страницу Google, оберните в декоратор и вызовите её:

@benchmark 
def fetch_webpage(): 
  import requests 
  webpage = requests.get('https://google.com')  





Декораторы. Таск 5
Декораторы.
Другой, важной задачей внутренней функции-обертки является работа с аргументами декорируемой функции. К примеру, мы должны применить декоратор к такой функции:

@decorator 
def func(arg1, arg2): 
   return arg1 + arg2 
Мы знаем что сама функция func попадет в качестве аргумента в наш декоратор:

def decorator(func): 
   ... 
так как, внутри декоратора есть функция-обертка, аргументы arg1 и arg2 декорируемой функции не потеряются, а попадут в обертку, после чего мы сможем обработать как саму функцию, так и аргументы:

def decorator(func): 
   def wrapper(arg1, arg2):  
   #здесь аргументы могут называться как угодно x, y и.т.п 
       try: 
           func(arg1, arg2) 
       except Exception: 
           print('Аргументы должны быть одного типа') 
   return wrapper 


@decorator 
def func(a, b): 
   return a + b 

func('строка',2) 
можем добавить конструкцию try-except, которая попытается запустить функцию func(arg1,arg2), так как в Python можно сложить только числа с числами или склеить строки со строками, то в except словим исключение и добавим сообщение 'Аргументы должны быть одного типа'.

Задание 5
Создайте словарь users и сохраните в нем несколько пользователей (ключом будет имя пользователя, а значением пароль пользователя). Напишите следующую функцию:

def login(username, password):
        print(f'Welcome, {username}')
Допишите к этой функции декоратор validate_password, который будет проверять есть ли в словаре пользователь с таким username и совпадает ли пароль.

Если такого username нет, то функция должна выводить сообщение:

Username is not defined 
Если же не совпадает password, т.е username сохранен с другим значением password, выведите сообщение:

Password is invalid 



def validate_password(func):
    ... 



    Декораторы. Таск 6
Декораторы.
Все методы и свойства аргументов декорируемой функции доступны также внутри декоратора.

К примеру, если аргументами являются строки, то будут доступны все методы - isupper(), count(), type(), срезы по индексу str[3:5] и.т.д.

Рассмотрим данный пример, где нам нужно написать декоратор проверяющий является ли список - аргумент функции, пустым:

@decorator 
def func(list): 
  return list 

func([]) 
так как аргумент list попадает в нашу функцию-обертку, а у всех списков есть такое свойство как len(), возвращающий нам длину списка, можем проверить с помощью if...else является ли длина списка больше нуля:

def decorator(func): 
  def wrapper(args): 
      if len(args) > 0: 
            func(args) 
      else: 
            print('Список не должен быть пустым') 
  return wrapper 
теперь, наш декоратор запустит функцию func только в том случае, если длина списка больше нуля, т.е список состоит из одного и более элементов.

Задание 6
Напишите функцию get_user, принимающую в аргументы словарь вида:

get_user({'username': 'john133', 'is_admin': True})
напишите также декоратор is_admin, который проверяет является ли юзер админом, если да выведите сообщение:

Доступ разрешен john133
если же юзер не админ:

Доступ запрещен john133
input:

@is_admin
def get_user(dict):
    return dict
 
get_user({'username': 'john133', 'is_admin': True})
get_user({'username': 'jane133', 'is_admin': False})
Доступ разрешен john133
Доступ запрещен jane133









@is_admin
def get_user(dict):
    return dict
 
get_user({'username': 'john133', 'is_admin': True})
get_user({'username': 'jane133', 'is_admin': False})













Декораторы. Таск 7
Декораторы.
Задание 7
Вам дана функция get_page(path), которая принимает в аргументы путь к определенной странице вашего вебсайта(https://www.mywebsite.com/).

Напишите декоратор route, который будет выводить абсолютный путь(url), к какой-либо странице:

Например, если передадим строку '/about' или '/products' в нашу функцию:

@route
def get_page(path):
     return path
 
print(get_page('about/'))
print(get_page('products/'))
После обработки декоратора, получим такой результат:

https://www.mywebsite.com/about/
https://www.mywebsite.com/products/





@route
def get_page(path):
     return path
 
print(get_page('about/'))
print(get_page('products/'))











Декораторы. Таск 8
Декораторы.
Помимо обработки исключений и if...else, в декораторах можно реализовать list, dictionary и set comptehensions. Напишем декоратор который проверит аргументы функции и вернет только те, что имеют значение True:

def decorator(func): 
  def wrapper(arg): 
      return [x for x in arg if x != False] 
  return wrapper 
возвращаем ключевым словом return список сгенерированный выражением [x for x in arg if x != False]:

которое возвращает каждый элемент x для каждого элемента x в списке, попадающий в переменную arg внутренней функции обертки-wrapper, если x не равно False.

Проверим декоратор на данной функции:

@decorator 
def func(list): 
   return list

print(func([1, False, 0, -2, True])) 
получим результат:

[1, -2, True] 
так как 0 у нас приравнивается к значению False, он не включен в конечный список.

Задание 8
Напишите функцию prefix_name, которая принимает в аргументы список, состоящий из кортежей:

name_format([('Leo', 'Nimoy', 40, 'M'),
('Carrie', 'Fisher', 35, 'F'),
('Harrison', 'Ford', 38, 'M')])
В каждом кортеже, через запятую хранится имя, фамилия, возраст и пол человека - 'M' - мужской, 'F' женский.

Функция должна возвращать строку - 'Ms. Carrie Fisher', с приставкой Ms. если это человек женского пола, и с приставкой Mr. если мужского - 'Mr. Leo Nimoy'.Также напишите декоратор sort_names, который возвратит осортированный по возрасту список имен(по возрастанию):

Ввод:

def sort_names(func):
     ...
 
@sort_names
     ...
def prefix_name(person):
     ...
 
print(prefix_name([('Leo', 'Nimoy', 40, 'M'),
      ('Carrie', 'Fisher', 35, 'F'),
      ('Harrison', 'Ford', 38, 'M')]))
Вывод должен быть:

['Ms. Carrie Fisher', 'Mr. Harrison Ford', 'Mr. Leo Nimoy']









print(prefix_name([('Leo', 'Nimoy', 40, 'M'),
      ('Carrie', 'Fisher', 35, 'F'),
      ('Harrison', 'Ford', 38, 'M')]))














Декораторы. Таск 9
Декораторы.
Задание 9
Напишите функцию sort_phone_nums которая принимает список телефонных номеров в виде строк:

sort_phone_nums(['0700987456', '0555123456', '0770369852'])
функция должна отсортировать по возрастанию список номеров и разделить их символом #.

Напишите декоратор get_full_number, который преобразует телефонные номера в sort_phone_nums, добавляя к ним региональный код +996 и убирая лишний ноль в начале номера:

+996 555 123456
+996 770 369852
+996 777 987456
Ввод:

def get_full_number(func):
    ...
@get_full_number
def sort_phone_nums(list_):
    ...
 
sort_phone_nums(['0777987456', '0555123456', '0770369852'])
Вывод:

+996 555 123456#+996 770 369852#+996 777 987456









Декораторы. Таск 10
Декораторы.
Помимо функции, декораторы могут принимать дополнительные аргументы. Для того чтобы использовать дополнительные аргументы, внутри декоратора нужно написать еще одну функцию-обертку.

К примеру, у нас будет декоратор который будет запускать декорируемую функцию, только в том случае если он получит строку 'start' в качестве аргумента:

def decorator(dec_arg): 
   def wrapper(func): 
       def wrapper2(func_arg): 
             if dec_arg == 'start': 
                 func(func_arg) 
             else: 
                 print('функция не запущена') 
       return wrapper2 
  return wrapper 
здесь, сам декоратор ловит аргумент декоратора dec_arg, функция-обертка wrapper получает декорируемую функцию func, вторая обертка - wrapper2 ловит аргумент функции func - func_arg.

Проводим проверку, является ли аргумент декоратора dec_arg строкой 'start', если да запускаем функцию func(func_arg), если же нет, возвращаем сообщение print('функция не запущена').

Проверим декоратор на данной функции:

@decorator('start') 
def func(word): 
   print(word)

func('Hello!') 
получим в результате:

Hello! 
Задание 10
Напишите декоратор type_check() который принимает в аргументы тип данных - str, int, list, dict и.т.д и проверяет подходит ли аргумент декорируемой функции по типу данных, к примеру, если у нас есть функция func1:

@type_check(int)
def func1(num):
    print(num*2)
наш декоратор приняв в аргументы int, должен проверить что аргумент функции num принадлежит именно типу данных int:

func1(2)

возвратит результат 4, если же передадим другой тип данных, к примеру словарь:

func1({1: 'какой-то', 2: 'словарь'})
декоратор возвратит строку:

Неверный тип данных :(
Ввод:

def type_check(correct_type):
 
    ...
 
@type_check(int)
def func1(num):
    print(num*2)
 
func1(2)
func1({1: 'какой-то', 2: 'словарь'})
Вывод:

4
Неверный тип данных :(   























     Принципы ООП. Магические методы. Таск 1
Магические методы.
Магические методы это специальные методы, которые начинаются и заканчиваются двойным подчеркиванием.

Эти методы не предназначены для непосредственного вызова, вызов происходит внутри класса при выполнении определенного действия.

Взаимодействие с кодом, другие методы и функции запускают магические методы без нашего вмешательства, это может быть создание объекта от класса - метод __init__, сложение чисел оператором плюс - метод __add__ и.т.д.

Мы уже использовали некоторые магические методы, и знаем что их можно переопределять и подстраивать под себя, например:

метод __init__ инициализирует объект, задает нашему объекту атрибуты
метод __str__ срабатывает когда выводим объект в терминал через функцию print() и возвращает человекочитаемый вид объекта
метод __repr__ возвращает в целом читаемый вид объекта, в отличие от __str__, не обязательно понятный человеку
есть еще такой магический метод как __del__, который срабатывает когда вы заканчиваете работу с объектом и сборщик мусора Python начинает подчищать память.
Задание 1
Создайте класс Account и переопределите в нем методы __init__, __repr__, __str__ и __del__.

Объекты класса должны содержать атрибуты:

name - имени держателя счета
balance - баланса
city - города, где открыт счет
Переопределенные методы:

__init__ должен также выводить сообщение "Счет создан"
__repr__ должен возвращать имя держателя счета и баланс
__str__ должен возвращать сообщение 'Hello' и также информацию о держателе счета: "Hello 'name' 'balance' 'city'" где вместо 'name', 'balance' и 'city' должны быть соответствующие значения атрибутов объекта.
__del__ должен выводить сообщение "Пока"
Создайте обьект класса obj_account с параметрами ('Rick', 2013, 'Bishkek') и вызовите все методы.

Ввод должен быть:

obj_account = Account("Rick", 2013, 'Bishkek')  
print(obj_account)  
print(repr(obj_account)) 
А вывод:

Счет создан   
Hello Rick 2013 Bishkek 
Rick 2013  
Пока 

















Принципы ООП. Магические методы. Таск 2
Магические методы.
В Python существует целая группа магических методов, срабатывающих тогда когда мы производим арифметические операции.

Данные методы вызываются как только мы ставим в нашем коде знаки арифметических операторов + - * / // ** % | и &

Например:

print(42 + 42) 
print('makers' + 'bootcamp') 
    #в обоих случаях срабатывает метод __add__

print(21 - 1) 
    #срабатывает метод __sub__

print(2 * 4) 
    #здесь вызывается метод __mul__

print(15 // 3) 
    #а здесь метод __floordiv__ 
Эти методы также можно переопределять для своих классов.

Например, у нас есть класс MyClass, где мы переопределим метод для оператора // :

class MyClass: 
     def __init__(self, num): 
             self.num = num

     def __floordiv__(self, num2): 
             return f'Деление без остатка равно: {self.num//num2}'
    
#здесь в self.num будет попадать число из атрибута объекта num, а в num2 попадает второе число после оператора //
создадим объект от класса, со значением num равным 5 и поделим наш объект на 2:

obj = MyClass(5) 
print(obj // 2) 
в терминале получим:

Деление без остатка равно: 2 
в этом примере 2 попало в переменную num2 метода __floordiv__, а из самого объекта obj, метод __floordiv__ взял указанный атрибут num.

Задание 2
Определите класс MyNumber который наследуется от класса int.

У экземпляра класса должен быть обязательный атрибут value.

Переопределите методы сложения, вычитания, умножения и деления для класса таким образом чтобы при использовании операторов + - * /, результат возвращался с сообщением:

"Это сложение и результат равен: x"   
      #для оперетора + 
"Это вычитание и результат равен: x"  
      #для '-'   
"Это умножение и результат равен: x"  
      #для '*' 
"Это деление и результат равен: x"  
      #для '/' 
где вместо x должен быть результат вычислений.

Создайте обьект от класса MyNumber в переменной obj_int cо значением равным 5.

Примените все операторы по порядку +,-,*,/.

Ввод должен быть:

obj_int = MyNumber(5)  
print(obj_int + 5)  
print(obj_int - 5)  
print(obj_int * 5)  
print(obj_int / 5)  
Вывод:

Это сложение и результат равен: 10  
Это вычитание и результат равен: 0  
Это умножение и результат равен: 25  
Это деление и результат равен: 1.0 




























Принципы ООП. Магические методы. Таск 3
Магические методы.
В Python все является объектом, а значит магические методы можно встретить везде, в том числе и в отдельных типах данных.

Посмотреть список магических методов можно применив функцию dir() к объекту или к классу и распечатав результат в терминал. К примеру, выведим магические методы списков:

print(dir(list)) 
получим данный список:

[ ... '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__' ...]
Зная за что отвечает тот или иной метод его можно легкo переопределить.

Так, переопределив метод __getitem__ у списков, можно изменить поведение объекта, при попытке вывести отдельный элемент списка.

Изменим метод так чтобы, при выводе элемента по индексу, возвращалась строка:

class Spisok(list): 
     def __init__(self,mylist): 
             self.mylist = mylist 
     def __getitem__(self, index): 
             return f'на этом месте стоит элемент {self.mylist[index]}'

lst = Spisok(['первый','второй', True]) 
print(lst[0])
метод __getitem__ получает в переменную index индекс элемента, который мы хотим получить(число передаемое в скобках), а в self попадает сам объект.

в терминале получим:

на этом месте стоит элемент первый 
Задание 3
Напишите класс MyList, который наследуется от list.

Сделайте так, чтобы индексация элементов начиналась с 1.

Создайте обьект obj_list и проверьте работоспособность программы.

Ввод должен быть:

obj_list = MyList([1,2,3,4,5])  
print(obj_list[1])  
А вывод:

1 
















Принципы ООП. Магические методы. Таск 4
Магические методы.
Для операторов сравнения также существует своя группа магических методов.

Это:

__eq__ - для оператора равенства, ==

__ne__ - для оператора неравенства, !=

__lt__ - для оператора меньше, <

__gt__ - для оператора больше, >

__le__ - для оператора меньше или равно, <=

__ge__ - для оператора больше или равно, >=

каждый из этих методов получает два аргумента self - попадает наш объект к которому мы применяем сравнение и other - второе передаваемое значение, с чем мы сравниваем.

(помним что self, other это просто переменные, можно называть как угодно, главное соблюдать порядок передачи аргументов)

Задание 4
Напишите класс Student, который описывает студента.

У студента есть следующие атрибуты: имя(name), класс(class_name), и оценки(ball) по предметам в виде словаря, в следующем виде: {’math’: 100, ‘history’: 89, literature’: 88}.

Переопределите методы сравнения >, < ,>=, <= так, чтобы сравнение студентов между собой производилось по средней оценке студента по предметам.

Создайте два обьекта от класса Student в переменных obj_student1 и obj_student2.

Сравните эти два объекта знаками >, < ,>=, <=, и распечатайте результат.

Ввод у вас должен быть:

obj_student1 = Student('a', 'A', {'math': 100, 'history': 50, 'literature': 88})  
obj_student2 = Student('b', 'Aa', {'math': 100, 'history': 50, 'literature': 88})  
print(obj_student1 > obj_student2)  
print(obj_student1 < obj_student2)  
print(obj_student1 >= obj_student2)  
print(obj_student1 <= obj_student2)  
Вывод должен быть в виде строки:

> False 
< False 
>= True 
<= True 






















Принципы ООП. Магические методы. Таск 5
Магические методы.
Задание 5
Напишите класс Word и переопределите методы 'больше чем', 'меньше чем', 'больше или равно', 'меньше или равно' для сравнения объектов класса - строк по длине(len).

Также в методе __new__ напишите условие для удаления пробелов и пустых строк в созданных словах.

Создайте обьекты word1 и word2 класса Word и сделайте сравнения.

Ввод:

word1 = Word('H  e  l  l  o')  
word2 = Word('world!')  
print(word1 > word2)  
print(word1 < word2)  
print(word1 >= word2)  
print(word1 <= word2) 
Вывод должен быть:

False  
True  
False  
True 













Принципы ООП. Магические методы. Таск 6
Магические методы.
Задание 6
Создайте класс Kopilka, у экземпляров класса должны быть приватные атрибуты:

total - общее количество накопленных монет, изначально равно 0
coins список монет которые были брошены в копилку, изначально пуст - [].
Добавьте метод add_moneta, который принимает аргумент moneta, и увеличивает total на данное значение, а также добавляет монету в список coins.

Переопределите в классе магические методы __len__ и __getitem__ таким образом, чтобы при применении функции len к объекту выдавалось количество монет в списке coins, а при попытке перебора объекта класса циклом for, печатались монеты из списка.

Создайте объект obj от класса Kopilka, вызовите все методы класса, примените функцию len() и переберите объект циклом for.

Ввод должен быть:

obj = Kopilka() 
obj.add_moneta(25) 
obj.add_moneta(30)

print(len(obj) 
for i in obj: 
     print(i) 
А вывод:

2 
25 
30 












Принципы ООП. Магические методы. Таск 7
Магические методы.
Задание 7
Создайте класс Anagram который наследуется от класса str.

Переопределите магический метод отвечающий за сравнение так чтобы, знак == сравнивал объекты класса, строки, на то являются ли они анаграммами или нет.

Также переопределите магический метод с помощью которого можно размножить строки: 2 * "hello" обычно возвращает "hellohello", сделайте так чтобы результат возвращался в обратном порядке как: "olleholleh"

Создайте экземпляры класса в переменных word1 и word2, сравните их оператором == и размножьте word1 на 3.

Ввод должен быть:

word1 = Anagram('hello') 
word2 = Anagram('olleh') 
print(word1 == word2) 
print(word1 * 3) 
Вывод:

True 
olleholleholleh









ООП. Методы класса и статические методы. Таск 1
Методы класса, экземпляра и статические методы.
При работе с классами в Python, различают три вида методов:

методы экземпляра - все те методы которые мы создавали для работы с объектом от класса.
Методы экземпляра класса принимают объект класса как первый аргумент, то что мы обычно называем self.

К примеру, у нас есть класс для домашних растений Plant:

class Plant: 
     oxygen = 900 

     def __init__(self, height): 
         self.height = height 

     def grow(self, cm): 
         self.height += cm 
         self.oxygen += 35 
         return self.height 
у объектов Plant есть метод grow, принимающий ссылку на объект self, и cm - на сколько сантиметров выросло растение.

Каждый раз как растение растет, высота растения height увеличевается, также увеличивается количество кислорода выделяемое растением - oxygen(переменная класса).

Создадим объект и применим метод:

kaktus = Plant(10) 
print(kaktus.grow(2)) 
print(kaktus.oxygen) 
получим в терминале:

12 
935 
Как мы видим, методы экземпляра класса могут менять состояние и отдельного объекта и самого класса.

методы класса - принимают в параметры ссылку на сам класс, обычно обозначают переменной cls, и декорируются декоратором @classmethod.
Например, у нашего класса есть переменная класса season, можем написать метод класса, который будет менять season на новое значение:

class Plant: 
     season = 'зима' 

     @classmethod 
     def change_season(cls, value): 
         cls.season = value 

Plant.change_season('весна') 
kaktus = Plant() 
ficus = Plant() 
print(kaktus.season, ficus.season) 
получим в терминале:

весна весна 
Методы класса меняют состояние всего класса, и это отражается на всех объектах созданных от класса.Однако методы класса не могут менять состояние конкретного, одного объекта.

статические методы - создаются при помощи декоратора @staticmethod, данные методы не принимают ни объект, ни класс.
Такие методы полезны для создания вспомогательных функций(простое преобразование из одного типа в другой, расчеты и.т.д).

Например:

class Plant:

     @staticmethod 
     def is_blooming(season): 
         if season == 'весна': 
                 print('Да') 
         else:  
                 print('Нет') 
мы создали статический метод проверяющий цветут ли наши растения сейчас(допустим что они цветут только весной), можем вызвать метод через класс и передать сезон:

Plant.is_blooming('осень') 
получим:

Нет 
Статические методы не имеют доступа к атрибутам экземпляра класса и к атрибутам самого класса.

Задание 1
Создайте класс Product, для какого-либо продукта, у класса должна быть переменная класса - base_price, базовая цена, равная 20000.

Экземпляры класса должны иметь атрибуты model, year и color.

Создайте для класса метод has_garantiya() принимающий в переменную year год и проверяющий действительна ли гарантия на продукт, если с указанного года прошло больше 2х лет, возвращайте строку:

Ваша гарантия истекла 
в противном случае:

Гарантия действительна 
Также создайте метод класса change_price(), который повышает базовую цену на процент переданный в переменную rate - процент инфляции.

Создайте от класса объект obj примените все методы.

Ввод должен быть:

obj = Product('A218', 2008, 'red') 
obj.change_price(2) 
print(obj.has_garantiya(2010)) 
print(obj.base_price) 
А вывод:

Гарантия действительна 
40000 






























ООП. Методы класса и статические методы. Таск 2
Методы класса, экземпляра и статические методы.
Методы класса можно использовать также для создания новых объектов от класса.

К примеру, у нас есть класс Contact, экземпляры которого имеют атрибуты name и phone:

class Contact:

     def __init__(self, name, phone): 
         self.name = name 
         self.phone = phone 
Представим что мы получаем данные от пользователя в виде списка [имя, телефон], и нам нужно создавать объекты от подобных списков.

Для этого, можем создать свой конструктор объектов через метод класса:

class Contact: 
 . . . 
     @classmethod 
     def from_list(cls, lst): 
         name = lst[0] 
         phone = lst[1] 
         return cls(name, phone) 
декорируем метод from_list декоратором @classmethod, метод будет принимать в аргументы сам класс и список(lst).

Внутри метода в переменную name и phone запишем элементы списка по индексам - 0 и 1.

В конце передадим в класс(cls), наши значения из списка в переменных name и phone.

Применим метод from_list к классу и передадим список:

contact = Contact.from_list(['John', '0550550550']) 
print(contact) 
распечатав переменную где хранится объект, получим:

<__main__.Contact object at 0x7fd87b82cfd0> 
т.е в переменной contact хранится объект принадлежащий к классу Contact.

Задание 2
Создайте класс User, объекты которого имеют атрибуты - name, lastname, email.

Создайте статический метод validate_email, который проверяет есть ли в имейле знак собачки @ и возвращает True либо False.

Переопределите метод __str__ так чтобы если у юзера был валидный имейл при использовании print() вам возвращалась строка:

"{Имя юзера}: {имейл}"

где вместо Имя юзера и имейл должны быть соответствующие значения.

В противном случае должна быть строка:

"email в неправильном формате".

Создайте класс метод create_user, который может создавать объекты от класса User из строк, переданных в таком формате - "Имя, Фамилия, имейл".

Например:

user1 = User.create_user('John, Snow, john@email.com') 
применив метод create_user получим объект с John в атрибуте name, Snow в атрибуте lastname и john@email.com в атрибуте email.

Создайте 2 экземпляра класса User - user1 и user2, где user2 должен иметь неправильный имейл(без @). Распечатайте эти объекты .

Ввод должен быть:

print(user1) 
print(user2) 
А вывод:

John: john@gmail.com 
email в неправильном формате 






















ООП. Методы класса и статические методы. Таск 3
Методы класса, экземпляра и статические методы.
Задание 3
Напишите класс учеников Makers, который будет содержать 4 атрибута:

атрибут экземпляра класса name (имя студента)
атрибут экземпляра класса language (язык, которому обучается студент)
атрибут экземпляра класса kpi (оценка студента)
атрибут класса students_count (количество учеников)
Также класс должен содержать следующие методы:

класс-метод new_student, который будет создавать нового ученика (экземпляр класса), и при этом увеличивать количество студентов на 1.
метод get_info, который будет возвращать имя и язык, выбранный учеником.
а также метод set_kpi, который будет устанавливать и возвращать оценку ученика.
Создайте двух студентов student1, student2 и примените к ним методы set_kpi и get_info. В конце вывести общее количество студентов.

Ввод должен быть:

print(student1.set_kpi(89)) 
print(student1.get_info()) 
print(student2.set_kpi(89)) 
print(student2.get_info()) 
print(Makers.student_count) 
Вывод:

89 
Student name: Vlad, Language: Python 
89 
Student name: Malik, Language: JavaScript 
2 



















ООП. Методы класса и статические методы. Таск 4
Методы класса, экземпляра и статические методы.
Задание 4
Создайте класс Bike в котором будут инициализированы следующие атрибуты:

self.cost (стоимость)
self.make (производитель)
self.model (модель)
self.year (год выпуска)
self._sale_price = None (цена для продажи, по умолчанию None)
self.sold = False (продан или нет, по умолчания False)
self.min_profit (мин. прибль, которая должна прийти с продажи велосипеда)
Создайте метод set_cost для указания цены для продажи, который принимает цену и устанавливает ее если она больше стоимости, а если она меньше стоимости, то ставит дефолтную цену для продажи (стоимость + мин. прибыль).

Для ремонта велосипеда будет использоваться метод service, который принимает стоимость ремонта велосипеда, соответственно продажная цена велосипеда возрастает на столько, сколько обошелся ремонт и возвращает новую цену для продажи.

При продаже велосипеда будет использоваться метод sell, который меняет значение self.sold на True и возвращает прибыль с продажи.

Допишите метод класса get_default_bike, который будет создавать дефолтный велосипед со следующими параметрами: (10000, "Author", "Basic ASL", 2020, 2000).

Создайте объект:

bike = Bike.get_default_bike() 
Используете метод set_cost с аргументом 6000 затем service cо значением 300, и проверьте значения всех его атрибутов. (распечатайте print(bike.cost) и.т.д).

Ввод должен быть:

bike = Bike.get_default_bike() 
bike.set_cost(6000) 
bike.service(300) 
print(bike.sell()) 
print(bike.cost) 
print(bike.make) 
print(bike.year) 
print(bike._sale_price) 
print(bike.sold) 
print(bike.min_profit) 
Вывод:

1700 
10000 
Author 
2020 
8300 
True 
2000 
















ООП. Методы класса и статические методы. Таск 5
Методы класса, экземпляра и статические методы.
Задание 5
Создайте класс MoneyFmt, экземпляры класса должны иметь один единственный атрибут amount. Создайте static метод dollarize, который принимает дробное число float в переменную float_num и переводит его в долларизованный формат, то есть:

dollarize(123456.78901) --> "$123,456.80"

dollarize(-123456.7801) --> "-$123,456.78"

dollarize(1000000) --> "$1,000,000"

Класс должен содержать 5 метода:

__init__ - инициализирует значение атрибута amount
update - задаёт объекту новое значение amount
__repr__ - возвращает значение float
dollarize - статический метод
__str__ - метод, который использует метод dollarize()
Создайте обьект cash класса MoneyFmt.

Ввод у вас должен быть:

cash = MoneyFmt(12345678.021) 
print(cash) 
cash.update(100000.4567) 
print(cash) 
cash.update(-0.3) 
print(cash) 
print(repr(cash)) 
Вывод:

$12,345,678.02 
$100,000.46 
-$0.30 
-0.3 











Основы Python

14 лекций


Linux

Основы GIT

Обзор типов данных

Типы данных. Числа

Строки

Логические Выражения

Списки

Словари

Кортежи и Множества

Comprehensions

Try-except

Функции

Области видимости

Встроенные функции
Продвинутый Python

16 лекций


Файлы

JSON

GIT

HTML

CSS

Парсинг

Введение в ООП

ООП Наследование

ООП Полиморфизм

ООП Инкапсуляция

ООП Миксины

Postgresql

Варианты операций

Виды связей. Join. Case

Индексы

ORM
Django

7 лекций


Введение в Django

django

Введение в Django Rest Framework

Serializer

ViewSet. Router

Регистрация. Код Активации

Permissions, Фильтрация, Поиск, Пагинация
CV&CL

1 лекций




10 лекций


Декораторы

Магические методы

Class, static, instance методы

HTTP

django-models

django-queryset

django-forms

django-crud

django-crud-cbv

django-rap




